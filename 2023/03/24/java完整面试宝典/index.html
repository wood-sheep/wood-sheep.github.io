<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>java面试宝典 | FDJ's Blog</title><meta name="author" content="复读机"><meta name="copyright" content="复读机"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="附加题：1、&amp;和&amp;&amp;区别123&amp;和&amp;&amp;都可以用作逻辑与运算符，表示逻辑与(and)。当运算符两边的表达式的结果都为true时，整个运算结果才为true。否则，只要有一方为false。则结果为false&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式&amp;还可以用作位运算符，当&amp;操作符两边的表达式">
<meta property="og:type" content="article">
<meta property="og:title" content="java面试宝典">
<meta property="og:url" content="https://171600.xyz/2023/03/24/java%E5%AE%8C%E6%95%B4%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/index.html">
<meta property="og:site_name" content="FDJ&#39;s Blog">
<meta property="og:description" content="附加题：1、&amp;和&amp;&amp;区别123&amp;和&amp;&amp;都可以用作逻辑与运算符，表示逻辑与(and)。当运算符两边的表达式的结果都为true时，整个运算结果才为true。否则，只要有一方为false。则结果为false&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式&amp;还可以用作位运算符，当&amp;操作符两边的表达式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://t.lizi.moe/fj">
<meta property="article:published_time" content="2023-03-24T01:12:44.000Z">
<meta property="article:modified_time" content="2023-03-24T02:05:52.331Z">
<meta property="article:author" content="复读机">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://t.lizi.moe/fj"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://171600.xyz/2023/03/24/java%E5%AE%8C%E6%95%B4%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java面试宝典',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-03-24 10:05:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="footer.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.lizi.moe/fj')"><nav id="nav"><span id="blog-info"><a href="/" title="FDJ's Blog"><span class="site-name">FDJ's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java面试宝典</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-24T01:12:44.000Z" title="发表于 2023-03-24 09:12:44">2023-03-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-24T02:05:52.331Z" title="更新于 2023-03-24 10:05:52">2023-03-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/blog/">blog</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java面试宝典"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="附加题："><a href="#附加题：" class="headerlink" title="附加题："></a>附加题：</h1><h2 id="1、-amp-和-amp-amp-区别"><a href="#1、-amp-和-amp-amp-区别" class="headerlink" title="1、&amp;和&amp;&amp;区别"></a>1、&amp;和&amp;&amp;区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;和&amp;&amp;都可以用作逻辑与运算符，表示逻辑与(and)。当运算符两边的表达式的结果都为true时，整个运算结果才为true。否则，只要有一方为false。则结果为false</span><br><span class="line">&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式</span><br><span class="line">&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作</span><br></pre></td></tr></table></figure>

<h2 id="2、jdk和jre区别"><a href="#2、jdk和jre区别" class="headerlink" title="2、jdk和jre区别"></a>2、jdk和jre区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdk是java开发工具包，里面包含jre和java开发工具，比如：java.exe（java运行工具）  javac.exe(java编译工具) jar.exe(打包工具)</span><br><span class="line">jre是java程序运行环境 包含jvm和核心类库</span><br></pre></td></tr></table></figure>

<h2 id="3、switch支持的数据类型"><a href="#3、switch支持的数据类型" class="headerlink" title="3、switch支持的数据类型"></a>3、switch支持的数据类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte、short、int、char、String、枚举 以上基本数据类型对应的包装类</span><br></pre></td></tr></table></figure>

<h2 id="4、JVM内存划分"><a href="#4、JVM内存划分" class="headerlink" title="4、JVM内存划分"></a>4、JVM内存划分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">栈内存：</span><br><span class="line">	存储方法内部声明的局部变量</span><br><span class="line">	方法声明的参数和大括号&#123;&#125;内部声明的变量都属于局部变量</span><br><span class="line">堆内存：</span><br><span class="line">	存储所有new出来的数据</span><br><span class="line">	堆内存的数据都有内存地址 内存地址用十六进制表示 eg:0x1234</span><br><span class="line">	堆内存的数据都有默认值</span><br><span class="line">	byte short int long 默认值为0</span><br><span class="line">	float double 默认值为0.0</span><br><span class="line">	boolean      默认值为false</span><br><span class="line">	char         &#x27;\u0000&#x27; 空字符</span><br><span class="line">	引用数据类型   默认值为null</span><br><span class="line">方法区  存储.class文件相关信息  比如 类名 方法声明等等</span><br><span class="line">本地方法栈  系统相关</span><br><span class="line">寄存器   	cpu相关</span><br></pre></td></tr></table></figure>

<h2 id="5、值传递和引用传递的区别"><a href="#5、值传递和引用传递的区别" class="headerlink" title="5、值传递和引用传递的区别"></a>5、值传递和引用传递的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">值传递：</span><br><span class="line">	基本数据类型做的是值传递，将当前变量的值复制一份存入其他变量，对其他变量的值进行修改时，当前变量的值没有影响</span><br><span class="line">引用传递(内存地址的传递):</span><br><span class="line">	引用数据类型做的是引用传递，将当前引用变量的内存地址存入其他引用变量，通过其他引用变量对堆中的值修改时，当前引用变量获取的是堆中修改以后的值</span><br></pre></td></tr></table></figure>

<h2 id="6、成员变量和局部变量的区别："><a href="#6、成员变量和局部变量的区别：" class="headerlink" title="6、成员变量和局部变量的区别："></a>6、成员变量和局部变量的区别：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">作用域不同：</span><br><span class="line">	局部变量的作用域仅限于定义它的方法</span><br><span class="line">	成员变量的作用域在整个类内部都是可见的</span><br><span class="line">初始值不同：</span><br><span class="line">	java会给成员变量一个初始值</span><br><span class="line">	java不会给局部变量赋予初始值</span><br><span class="line">注意：</span><br><span class="line">	在同一个方法中，不允许有同名局部变量</span><br><span class="line">	在不同的方法中，可以有同名局部变量</span><br><span class="line">	</span><br><span class="line">	在同一个类中，成员变量和局部变量同名时，局部变量具有更高级的优先级</span><br></pre></td></tr></table></figure>

<h2 id="7、构造方法注意事项"><a href="#7、构造方法注意事项" class="headerlink" title="7、构造方法注意事项"></a>7、构造方法注意事项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">	1、构造方法声明不能写返回值，连void都不能写</span><br><span class="line">	2、构造方法一定与类名一致</span><br><span class="line">	3、如果类里面没有手写构造方法，默认提供无参构造方法</span><br><span class="line">	4、如果类里面写了构造方法，默认的无参构造方法不再提供</span><br><span class="line">推荐：</span><br><span class="line">	一定先写无参构造 再写带参构造</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="8、-static修饰变量-方法和代码块"><a href="#8、-static修饰变量-方法和代码块" class="headerlink" title="8、 static修饰变量 方法和代码块"></a>8、 static修饰变量 方法和代码块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static修饰的变量叫静态变量(类变量) 只和类相关 通过类名.静态变量名访问</span><br><span class="line">静态变量存在方法区内存，只保存一份</span><br><span class="line"></span><br><span class="line">static修饰的方法叫静态方法(类方法)，只和类相关 通过类名.静态方法名调动</span><br><span class="line">	注意事项：</span><br><span class="line">		1、静态方法只能直接访问静态变量和静态方法</span><br><span class="line">		2、静态方法不能直接访问成员变量和成员方法</span><br><span class="line">static修饰的代码块叫静态代码块，当第一次使用类时，静态代码块执行一次，后面不再执行</span><br><span class="line"></span><br><span class="line">成员方法可以访问成员变量和成员方法，还有静态变量和静态方法</span><br></pre></td></tr></table></figure>

<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="9、Object的toString"><a href="#9、Object的toString" class="headerlink" title="9、Object的toString()"></a>9、Object的toString()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认返回的可以理解为对象的内存地址</span><br></pre></td></tr></table></figure>

<h2 id="10、abstract抽象"><a href="#10、abstract抽象" class="headerlink" title="10、abstract抽象"></a>10、abstract抽象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abstract修饰的类叫抽象类</span><br><span class="line">抽象类不能创建对象</span><br><span class="line">abstract修饰的方法叫抽象方法，抽象方法没有方法体 以;号结束</span><br><span class="line">	1、子类继承父类 子类必须重写父类中所有抽象方法</span><br><span class="line">	   除非子类也是抽象类 抽象子类可以重写或者不重写</span><br><span class="line">	2、抽象方法所在的类必须是抽象类</span><br><span class="line">	</span><br><span class="line">如果抽象子类没有重写父类抽象方法，相当于继承了这些抽象方法</span><br></pre></td></tr></table></figure>

<h2 id="11、多态："><a href="#11、多态：" class="headerlink" title="11、多态："></a>11、多态：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">同一种事物的不同种表现形式</span><br><span class="line"></span><br><span class="line">多态： 父类类名 引用变量 = new 子类类名();  自动类型转换 向上转型</span><br><span class="line">父类变量调用的一定是子类重写的方法</span><br><span class="line"></span><br><span class="line">父类变量无法调用子类独有的方法，需要将父类强制转换子类</span><br><span class="line"></span><br><span class="line">引用变量 instanceof 类名</span><br><span class="line">	包含对象的类型和对象的直接父类或间接父类</span><br><span class="line">如果instanceof后面的类型是 对象类型 或者是对象的直接父类或者间接父类 都是返回true</span><br><span class="line"></span><br><span class="line">父类变量能调用：</span><br><span class="line">1、父类中声明的方法</span><br><span class="line">2、父类中声明过，然后子类重写的方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="12、访问修饰符"><a href="#12、访问修饰符" class="headerlink" title="12、访问修饰符"></a>12、访问修饰符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private 修饰的属性和方法  只能在本类中访问</span><br><span class="line">默认    修饰的属性和方法   本类和同包下的其他java类可以访问</span><br><span class="line">protected  修饰的属性和方法  本类和同包下的其他java类可以访问  如果是不同包下的子类，子类可以访问</span><br><span class="line">public 修饰的属性和方法 任何位置可以访问</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="13、内部类"><a href="#13、内部类" class="headerlink" title="13、内部类"></a>13、内部类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">成员内部类</span><br><span class="line">    1 在外部类要使用内部类，需要创建内部类对象访问</span><br><span class="line">    2 内部类可以直接外部类的成员</span><br><span class="line">    1、在外部类的成员方法里面使用 创建内部类对象</span><br><span class="line">    2、外部类名.内部类名 引用变量 = new 外部类名().new 内部类名();</span><br><span class="line">局部内部类（包含了匿名内部类）：</span><br><span class="line">	//只要是匿名内部类访问的局部变量，必须是final的，只能进行一次赋值</span><br><span class="line">	局部内部类地位等同于局部变量 前面不能加访问修饰符</span><br><span class="line">	局部内部类是可以直接访问所在方法的final的局部变量的</span><br><span class="line">	有一个前提 局部变量必须是final的常量</span><br><span class="line">	jdk1.7之前final必须加，jdk1.8开始给变量赋值以后final可以省略</span><br><span class="line">	匿名内部类属于局部内部类的，在方法内部声明，也在方法内部使用</span><br></pre></td></tr></table></figure>

<h2 id="14、10个异常名字"><a href="#14、10个异常名字" class="headerlink" title="14、10个异常名字"></a>14、10个异常名字</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">运行时异常</span><br><span class="line">    NullPointerException   空指针异常</span><br><span class="line">    ArrayIndexOutOfBoundsException   数组下标越界异常</span><br><span class="line">    IndexOutOfBoundsException        下标越界异常</span><br><span class="line">    ClassCastException               类型转换异常</span><br><span class="line">    NumberFormatException			 数字格式化异常</span><br><span class="line">检查异常（编译异常）</span><br><span class="line">	IOException</span><br><span class="line">    FileNotFoundException      文件找不到</span><br><span class="line">    ClassNotFoundException		类找不到，类加载</span><br><span class="line">    EOFException</span><br><span class="line">    SQLException</span><br></pre></td></tr></table></figure>



<h2 id="15、throws和throw的区别"><a href="#15、throws和throw的区别" class="headerlink" title="15、throws和throw的区别"></a>15、throws和throw的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、throws用在方法声明的位置，throw用在方法体内</span><br><span class="line">2、throws是可能出现异常 throw是一定出现异常</span><br><span class="line">3、throws后面跟异常类名 throw后面跟异常对象</span><br></pre></td></tr></table></figure>

<h2 id="JAVA语言如何进行异常处理-关键字-throws-throw-try-catch-finally分别代表什么意义-在try块中可以抛出异常吗"><a href="#JAVA语言如何进行异常处理-关键字-throws-throw-try-catch-finally分别代表什么意义-在try块中可以抛出异常吗" class="headerlink" title="JAVA语言如何进行异常处理,关键字:throws, throw,try, catch, finally分别代表什么意义?在try块中可以抛出异常吗?"></a>JAVA语言如何进行异常处理,关键字:throws, throw,try, catch, finally分别代表什么意义?在try块中可以抛出异常吗?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Try用来指定一块预防所有异常的程序</span><br><span class="line">Catch子句紧跟在try块后面，用来指定你想要捕捉的异常的类型</span><br><span class="line">Throw语句用来明确地抛出一个异常</span><br><span class="line">Throws用来标明一个成员函数可能抛出的各种异常</span><br><span class="line">Finally为确保一段代码不管发生什么异常都被执行一段代码</span><br><span class="line">在try块中是可以抛出异常的。</span><br></pre></td></tr></table></figure>

<h2 id="16、Error和Exception的区别"><a href="#16、Error和Exception的区别" class="headerlink" title="16、Error和Exception的区别"></a>16、Error和Exception的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Exception：非严重错误，程序员可以解决，异常分为运行时异常和检查异常，再说下两个异常概念</span><br><span class="line">    1．可以是可被控制(checked) 或不可控制的(unchecked)。</span><br><span class="line">    2．表示一个由程序员导致的错误。</span><br><span class="line">    3．应该在应用程序级被处理。</span><br><span class="line">Error： 严重错误，程序员无法解决的，例如，内存溢出</span><br><span class="line">    1．总是不可控制的(unchecked)。</span><br><span class="line">    2．经常用来用于表示系统错误或底层资源的错误。</span><br><span class="line">    3．如果可能的话，应该在系统级被捕捉。</span><br></pre></td></tr></table></figure>



<h2 id="17、异常分为运行时异常和检查异常（编译异常）："><a href="#17、异常分为运行时异常和检查异常（编译异常）：" class="headerlink" title="17、异常分为运行时异常和检查异常（编译异常）："></a>17、异常分为运行时异常和检查异常（编译异常）：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运行时异常：</span><br><span class="line">	所有RuntimeException类及其子类都属于运行时异常， 程序对运行时异常，可以选择处理或者不处理</span><br><span class="line">检查异常：</span><br><span class="line">	除了RuntimeException类及其子类都属于检查异常，程序要求对检查异常必须处理，否则编译不通过</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="18、调用者针对方法声明的异常有2种处理方法"><a href="#18、调用者针对方法声明的异常有2种处理方法" class="headerlink" title="18、调用者针对方法声明的异常有2种处理方法"></a>18、调用者针对方法声明的异常有2种处理方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、try catch  立即捕获异常处理异常</span><br><span class="line">2、继续在当前方法throws声明异常，将异常抛给下一个调用者</span><br><span class="line">注意：main声明的异常交给java虚拟机处理，java虚拟机的处理方式就是不处理，程序在异常位置立即结束</span><br></pre></td></tr></table></figure>



<h2 id="19、单例-懒汉式饿汉式"><a href="#19、单例-懒汉式饿汉式" class="headerlink" title="19、单例 懒汉式饿汉式"></a>19、单例 懒汉式饿汉式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">确保在程序运行时，一个类的实例有且仅有一个</span><br><span class="line">目的： 节省内存</span><br><span class="line">懒汉式单例</span><br><span class="line">	//懒汉式</span><br><span class="line">    public class User &#123;</span><br><span class="line">        //1 构造方法私有化</span><br><span class="line">        private User()&#123;&#125;;</span><br><span class="line">        //2 声明当前类数据类型的私有的静态变量</span><br><span class="line">        private static User user;</span><br><span class="line">        //3 声明一个获取当前类对象的静态方法</span><br><span class="line">        public static synchronized User getUser()&#123;</span><br><span class="line">            if (user == null)&#123;</span><br><span class="line">                user = new User();</span><br><span class="line">            &#125;</span><br><span class="line">            return user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">饿汉式单例</span><br><span class="line">    //饿汉式</span><br><span class="line">    public class Person &#123;</span><br><span class="line">        //1 构造方法私有化</span><br><span class="line">        private Person()&#123;&#125;</span><br><span class="line">        //2 声明当前类数据类型的静态变量，同时初始化  饿汉式</span><br><span class="line">        private static Person person = new Person();</span><br><span class="line">        //3 公共的获取当前类对象的静态方法</span><br><span class="line">        public static Person getPerson()&#123;</span><br><span class="line">            return person;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<h2 id="20、Collection和Collections的区别"><a href="#20、Collection和Collections的区别" class="headerlink" title="20、Collection和Collections的区别"></a>20、Collection和Collections的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection是集合的顶级接口 下面有List和Set2个子接口</span><br><span class="line">Collections是一个集合的操作类，里面提供了一些静态方法</span><br><span class="line">Collection：</span><br><span class="line">	是一个集合接口(集合类的一个顶级接口)，它提供了对集合对象进行基本操作的通用接口方法。</span><br><span class="line">	Collection接口在java类库中有很多具体的实现，Collection接口的意义是为各种具体的集合提供了最大化的统一操作方法，其直接继承接口有List和Set</span><br><span class="line">Collections：</span><br><span class="line">	是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等</span><br></pre></td></tr></table></figure>

<h2 id="21、泛型"><a href="#21、泛型" class="headerlink" title="21、泛型"></a>21、泛型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将类名作为集合的参数 写在集合名的右边</span><br><span class="line">    <span class="number">1</span>、限制当前集合只能存指定的Student类型的对象</span><br><span class="line">    <span class="number">2</span>、集合中全是Student类型的对象，所以get()方法取出的就是Student对象，不需要强转</span><br><span class="line">    考点：如果不写泛型，有默认的泛型是Object</span><br></pre></td></tr></table></figure>

<h2 id="22、ArrayList特点-扩容机制"><a href="#22、ArrayList特点-扩容机制" class="headerlink" title="22、ArrayList特点 扩容机制"></a>22、ArrayList特点 扩容机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询快，增删慢</span><br><span class="line">数组集合初识长度为10，之后以1.5倍扩容</span><br></pre></td></tr></table></figure>

<h2 id="23、hashMap底层原理"><a href="#23、hashMap底层原理" class="headerlink" title="23、hashMap底层原理*********"></a>23、hashMap底层原理*********</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">如果Node数组长度&gt;原始长度*加载因子  数组开始扩容</span><br><span class="line">第一次扩容 13大于 12= 16*0.75</span><br><span class="line"></span><br><span class="line">HashMap底层是哈希表数据结构</span><br><span class="line">jdk1.8开始	哈希表=Node数组+链表(单向链表)+红黑树(二叉树的一种)</span><br><span class="line">Node数组初始长度16 加载因子0.75  扩容到原数组的2倍</span><br><span class="line">单向链表的节点个数&gt;8 并且 数组长度&gt;64 链表转红黑树</span><br><span class="line">如果节点个数&lt;6 红黑树转回链表</span><br><span class="line"></span><br><span class="line">调用map.put(key,value)时，会调用key的hashcode方法计算出哈希值，</span><br><span class="line">这个哈希值会经过再次运算得到最终的哈希值，根据哈希值计算出在Node数组的存储下标，</span><br><span class="line">1、如果数组下标对应的空间没有值，key和value直接存入</span><br><span class="line">2、如果数组下标对应的空间有值(存在一个单向链表)，继续调用key的</span><br><span class="line">equals方法和单向链表中每个节点的key比较，</span><br><span class="line">    如果返回true，后面的value覆盖前面的value</span><br><span class="line">    如果返回false，key和value存入</span><br></pre></td></tr></table></figure>

<h2 id="24、hashcode和equals的区别和联系"><a href="#24、hashcode和equals的区别和联系" class="headerlink" title="24、hashcode和equals的区别和联系"></a>24、hashcode和equals的区别和联系</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hashCode()基于对象的内存地址计算一个整形值(哈希值)，并将整形值返回</span><br><span class="line">equals()默认使用==比较2个对象的内存地址是否相等</span><br><span class="line">关联1：</span><br><span class="line">	如果2个对象的equals相等，那么2个对象的hashcode一定相等</span><br><span class="line">关联2：</span><br><span class="line">	如果2个对象的equals不相等，那么2个对象的hashcode可能相等</span><br><span class="line">关联3：</span><br><span class="line">	如果2个对象的hashcode不相等，那么2个对象的equals一定不相等</span><br><span class="line">	//hashcode是可以在子类重写的</span><br><span class="line">    //jdk中String类重写了Object类的hashcode</span><br><span class="line">    //String类的hashCode()根据字符串内容计算整形值(哈希值)</span><br><span class="line">    //字符串内容一样，哈希值一样</span><br></pre></td></tr></table></figure>

<h2 id="25、ArrayList和LinkedList区别"><a href="#25、ArrayList和LinkedList区别" class="headerlink" title="25、ArrayList和LinkedList区别"></a>25、ArrayList和LinkedList区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList底层是数组 查询快 增删慢</span><br><span class="line">LinkedList底层是双向链表 查询慢 增删快</span><br></pre></td></tr></table></figure>

<h2 id="list和set的区别"><a href="#list和set的区别" class="headerlink" title="list和set的区别"></a>list和set的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、list可以允许重复对象，set不允许</span><br><span class="line">2、list方法可以插入多个null，set只允许插入一个null</span><br><span class="line">3、list是有序的，set是无序的</span><br></pre></td></tr></table></figure>

<h1 id="Collections类常用方法总结"><a href="#Collections类常用方法总结" class="headerlink" title="Collections类常用方法总结"></a>Collections类常用方法总结</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sort(Collection)方法的使用(含义：对集合进行排序)。</span><br><span class="line">reverse()方法的使用(含义：反转集合中元素的顺序)。</span><br><span class="line">shuffle(Collection)方法的使用(含义：对集合进行随机排序)。</span><br><span class="line">fill(List list,Object o)方法的使用(含义：用对象o替换集合list中的所有元素)</span><br><span class="line">copy(List m,List n)方法的使用(含义：将集合n中的元素全部复制到m中,并且覆盖相应索引的元素)。</span><br><span class="line">replaceAll(List list,Object old,Object new)方法的使用(含义：替换批定元素为某元素,若要替换的值存在刚返回true,反之返回false)。</span><br></pre></td></tr></table></figure>

<h1 id="Arrays数组操作"><a href="#Arrays数组操作" class="headerlink" title="Arrays数组操作"></a>Arrays数组操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asList()   返回一个list集合</span><br><span class="line">toString()   打印一个数组</span><br></pre></td></tr></table></figure>



<h1 id="Java集合类框架的基本接口有哪些？"><a href="#Java集合类框架的基本接口有哪些？" class="headerlink" title="Java集合类框架的基本接口有哪些？"></a>Java集合类框架的基本接口有哪些？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Collection：单列集合的根接口</span><br><span class="line">List:元素有序，可重复</span><br><span class="line">ArrayList:类似一个长度可变的数组，适合查询，不适合增删</span><br><span class="line">LinkedList：底层是双向循环链表，适合增删，不适合查询</span><br><span class="line">Set：元素无序，不可重复</span><br><span class="line">HashSet：根据对象的哈希值确定元素在集合中的位置</span><br><span class="line">TreeSet：以二叉树的方式存储元素，实现了对集合中的元素排序</span><br><span class="line">Map：双列集合的根接口，用于存储具有键、值映射关系的元素</span><br><span class="line">HashMap:用于存储键值映射关系，不能出现重复的键key</span><br><span class="line">TreeMap：用来存储键值映射关系，不能出现重复的键key，所有的键按照二叉树的方式排列</span><br><span class="line"></span><br><span class="line">总共有两大接口：Collection 和Map ，一个元素集合，一个是键值对集合； 其中List和Set接口继承了Collection接口，一个是有序元素集合，一个是无序元素集合； 而ArrayList和 LinkedList 实现了List接口，HashSet实现了Set接口，这几个都比较常用； HashMap 和HashTable实现了Map接口，并且HashTable是线程安全的，但是HashMap性能更好；</span><br></pre></td></tr></table></figure>



<h2 id="26、ArrayList、hashmap、hashtable扩容机制"><a href="#26、ArrayList、hashmap、hashtable扩容机制" class="headerlink" title="26、ArrayList、hashmap、hashtable扩容机制"></a>26、ArrayList、hashmap、hashtable扩容机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList数组初始长度10  扩容原来数组的1.5倍，等数组存满之后再存数据的时候开始扩容</span><br><span class="line">hashmap数组初始长度16 加载因子0.75  扩容到原数组的2倍 如果Node数组长度&gt;原始长度*加载因子  数组开始扩容</span><br><span class="line">hashtable中的数组初始长度为11，扩容原数组的2倍+1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="27、HashSet底层-照着HashMap底层回答"><a href="#27、HashSet底层-照着HashMap底层回答" class="headerlink" title="27、HashSet底层 照着HashMap底层回答"></a>27、HashSet底层 照着HashMap底层回答</h2><h2 id="28、字符串常量池"><a href="#28、字符串常量池" class="headerlink" title="28、字符串常量池"></a>28、字符串常量池</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jdk1.7之前 字符串常量池在方法区</span><br><span class="line">jdk1.7开始  字符串常量池在堆中</span><br><span class="line">&quot;&quot;包含的数据直接存在字符串常量池</span><br><span class="line">如果字符串常量池能找到字符串，直接返回字符串的内存地址，</span><br><span class="line">如果字符串常量池找不到字符串，创建字符串，返回内存地址</span><br></pre></td></tr></table></figure>

<h2 id="29、Integer有一个常量池-缓存了-128到127之间的值"><a href="#29、Integer有一个常量池-缓存了-128到127之间的值" class="headerlink" title="29、Integer有一个常量池 缓存了-128到127之间的值"></a>29、Integer有一个常量池 缓存了-128到127之间的值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer k = 127;  ====  Integer k = Integer.valueOf(127);</span><br><span class="line">相当于在常量池中找到了数字的内存地址存入变量中</span><br><span class="line">new出来的Integer，范围在-128到127也是新的内存地址</span><br></pre></td></tr></table></figure>

<h2 id="30、枚举"><a href="#30、枚举" class="headerlink" title="30、枚举"></a>30、枚举</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum Gender &#123;</span><br><span class="line">   //常量 所有字母大写</span><br><span class="line">   MAN,WOMAN</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//枚举数据类型的变量只能存枚举里面声明的常量，通过枚举名.常量名访问</span><br><span class="line">student.setGender(Gender.MAN);</span><br></pre></td></tr></table></figure>

<h2 id="31、线程同步的方式3种"><a href="#31、线程同步的方式3种" class="headerlink" title="31、线程同步的方式3种"></a>31、线程同步的方式3种</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、同步代码块</span><br><span class="line">2、同步方法</span><br><span class="line">3、lock锁</span><br></pre></td></tr></table></figure>

<h2 id="32、sleep和wait区别"><a href="#32、sleep和wait区别" class="headerlink" title="32、sleep和wait区别"></a>32、sleep和wait区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 sleep是Thread类的方法 wait是Object类的方法</span><br><span class="line">2 sleep不会释放对象锁  wait会释放对象锁的</span><br><span class="line">3 sleep的休眠时间到达后会自动进入就绪状态</span><br><span class="line">   wait的线程必须由notify方法唤醒，唤醒后进入同步阻塞状态</span><br></pre></td></tr></table></figure>

<h2 id="33、面向对象的基本特征"><a href="#33、面向对象的基本特征" class="headerlink" title="33、面向对象的基本特征"></a>33、面向对象的基本特征</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">封装：将类中所有成员变量私有化，提供公共的get和set</span><br><span class="line">继承：子类继承父类非私有的属性和方法</span><br><span class="line">多态：当父类类型的引用变量，保存不同的子类对象时，执行方法的结果是不一样的</span><br></pre></td></tr></table></figure>

<h2 id="34、深拷贝和浅拷贝"><a href="#34、深拷贝和浅拷贝" class="headerlink" title="34、深拷贝和浅拷贝"></a>34、深拷贝和浅拷贝</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝（shallowCopy）拷贝出一个新的对象，新对象中的基本数据类型的变量是复制了一份，引用类型和旧对象中的引用类型指向堆中同一个数据</span><br><span class="line">深拷贝（deepCopy）会创造一个新的对象，修改新对象不会影响原对象的属性值</span><br><span class="line">Object o1 = new Object();</span><br><span class="line">Object o2 = new Object();</span><br><span class="line">o2.setId(o1.getId);</span><br></pre></td></tr></table></figure>

<h2 id="35、如何退出多重循环"><a href="#35、如何退出多重循环" class="headerlink" title="35、如何退出多重循环"></a>35、如何退出多重循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用标签变量</span></span><br><span class="line"><span class="comment">// 标签名的命名方法是：java命名规则 和 半角冒号   比如： lableA: </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    lableB:</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        lableA:</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span> lableB;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;		</span><br><span class="line">    System.out.println(<span class="string">&quot;over!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="char型变量中能不能存贮一个中文汉字-为什么"><a href="#char型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="char型变量中能不能存贮一个中文汉字?为什么?"></a>char型变量中能不能存贮一个中文汉字?为什么?</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，</span><br><span class="line">所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，</span><br><span class="line">那么，这个char型变量中就不能存储这个特殊汉字。</span><br><span class="line">补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节</span><br></pre></td></tr></table></figure>

<h1 id="说出一些常用的类，包，接口，请各举5个"><a href="#说出一些常用的类，包，接口，请各举5个" class="headerlink" title="说出一些常用的类，包，接口，请各举5个"></a>说出一些常用的类，包，接口，请各举5个</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer java.util.Date，System，Class，List,HashMap</span><br><span class="line">常用的包：java.lang java.io java.util</span><br><span class="line">java.sql ,javax.servlet,org.apache.strtuts.action,org.hibernate</span><br><span class="line">常用的接口：Remote List Map Document</span><br><span class="line">NodeList,Servlet,HttpServletRequest,HttpServletResponse,Transaction(Hibernate)</span><br><span class="line">Session(Hibernate),HttpSession</span><br></pre></td></tr></table></figure>

<h1 id="描述final-finally-finalize的区别？"><a href="#描述final-finally-finalize的区别？" class="headerlink" title="描述final, finally, finalize的区别？"></a>描述final, finally, finalize的区别？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final用于声明属性，方法和类，修饰的类不能被继承，例如String，修饰的方法不能被重写，修饰的属性为常量，一旦被赋值不能被修改</span><br><span class="line">finally是异常处理语句结构的一部分，表示总是执行</span><br><span class="line">finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等，jvm不保证此方法总被调用</span><br></pre></td></tr></table></figure>



<h1 id="1、java有哪些基本数据类型-什么是自动装箱？"><a href="#1、java有哪些基本数据类型-什么是自动装箱？" class="headerlink" title="1、java有哪些基本数据类型 什么是自动装箱？"></a>1、java有哪些基本数据类型 什么是自动装箱？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">byte  Byte 	1  -128~127</span><br><span class="line">short Short	2  -32768~32767</span><br><span class="line">int   Integer 	4  -21亿~21亿</span><br><span class="line">long   Long 	8   19位</span><br><span class="line">float  Float	4	39位</span><br><span class="line">double  Double 	8    </span><br><span class="line">char Character	2   0~65535</span><br><span class="line">boolean Boolean	1</span><br><span class="line">自动装箱  将基本数据类型自动转换对应的包装类</span><br><span class="line">自动拆箱  将包装类自动转换对应的基本数据类型</span><br><span class="line"></span><br><span class="line">int和Integer有什么区别？</span><br><span class="line">	1、Integer是int的包装类，int是基本数据类型</span><br><span class="line">	2、Integer变量必须实例化后才能使用，int变量不需要</span><br><span class="line">	3、Integer实际是对象的引用，指向此new的Integer对象，int是直接存储数据值</span><br><span class="line">	4、Integer的默认值是null，int的默认值是0</span><br></pre></td></tr></table></figure>

<h1 id="2、算法实现之在不引入其他变量的情况下让int变量a和int变量b互换"><a href="#2、算法实现之在不引入其他变量的情况下让int变量a和int变量b互换" class="headerlink" title="2、算法实现之在不引入其他变量的情况下让int变量a和int变量b互换"></a>2、算法实现之在不引入其他变量的情况下让int变量a和int变量b互换</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br><span class="line"></span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3、编写一个方法输出1-100之间的所有的素数，所谓素数：只能被1和本身整除的称为素数"><a href="#3、编写一个方法输出1-100之间的所有的素数，所谓素数：只能被1和本身整除的称为素数" class="headerlink" title="3、编写一个方法输出1-100之间的所有的素数，所谓素数：只能被1和本身整除的称为素数"></a>3、编写一个方法输出1-100之间的所有的素数，所谓素数：只能被1和本身整除的称为素数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;=<span class="number">100</span> ; i++) &#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt; i ; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i%j == <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag)&#123;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4、有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"><a href="#4、有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？" class="headerlink" title="4、有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"></a>4、有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">4</span> ; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">4</span> ; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j == i)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= <span class="number">4</span> ; k++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k == i || k == j)&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			count++;</span><br><span class="line">			System.out.println(i*<span class="number">100</span> + j*<span class="number">10</span> + k;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;总个数为：&quot;</span> + count);</span><br></pre></td></tr></table></figure>

<h1 id="5、冒泡排序"><a href="#5、冒泡排序" class="headerlink" title="5、冒泡排序"></a>5、冒泡排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123; <span class="number">20</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">			nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">			nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6、一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在-第10次落地时，共经过多少米？第10次反弹多高？"><a href="#6、一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在-第10次落地时，共经过多少米？第10次反弹多高？" class="headerlink" title="6、一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在 第10次落地时，共经过多少米？第10次反弹多高？"></a>6、一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在 第10次落地时，共经过多少米？第10次反弹多高？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">double height = 100;</span><br><span class="line">double len = 0;</span><br><span class="line">int num = 10;</span><br><span class="line">for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">	len = len + height + height/2;</span><br><span class="line">	height /= 2;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;第&quot; + num + &quot;次反弹了&quot; + height + &quot;米&quot;);</span><br><span class="line">System.out.println(&quot;共经过了&quot;+ (len-height) + &quot;米&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="7、静态变量和实例变量的区别？"><a href="#7、静态变量和实例变量的区别？" class="headerlink" title="7、静态变量和实例变量的区别？"></a>7、静态变量和实例变量的区别？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 静态变量只和类相关 通过类名调用</span><br><span class="line">   成员变量和对象相关 需要先创建对象 通过对象名调用</span><br><span class="line">2 静态变量存在方法区内存  成员变量存在堆内存</span><br></pre></td></tr></table></figure>

<h1 id="8、说说final关键字的用法？"><a href="#8、说说final关键字的用法？" class="headerlink" title="8、说说final关键字的用法？"></a>8、说说final关键字的用法？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 final修饰的类不允许有子类</span><br><span class="line">2 final修饰的方法不能被子类重写</span><br><span class="line">3 final修饰的变量是常量</span><br><span class="line">   常量一旦赋值，不允许修改</span><br></pre></td></tr></table></figure>

<h1 id="9、选择排序算法"><a href="#9、选择排序算法" class="headerlink" title="9、选择排序算法"></a>9、选择排序算法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">5</span>,<span class="number">20</span>,<span class="number">50</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">	<span class="comment">//每次循环将第一个值当做最小值，将最小值的下标存入min</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; nums.length ; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[min]&gt;nums[j])&#123;</span><br><span class="line">			min = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (min!=i)&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">		nums[i] = nums[min];</span><br><span class="line">		nums[min] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(nums));</span><br></pre></td></tr></table></figure>

<h1 id="10、-x3D-x3D-和equals区别"><a href="#10、-x3D-x3D-和equals区别" class="headerlink" title="10、&#x3D;&#x3D; 和equals区别"></a>10、&#x3D;&#x3D; 和equals区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==</span><br><span class="line">如果2边是基本数据类型，做的是值的比较</span><br><span class="line">如果2边是引用数据类型，做的是内存地址的比较</span><br><span class="line">Object类的equals()</span><br><span class="line">默认是使用==判断2个对象的内存地址是否相等</span><br><span class="line">重写以后按照自定义规则比较2个对象</span><br></pre></td></tr></table></figure>

<h1 id="11、创建一个子类对象，请写出：父类静态代码块，父类构造方法，父类代码块，子类代码块，子类构造，子类静态代码块。这六个对象的执行顺序"><a href="#11、创建一个子类对象，请写出：父类静态代码块，父类构造方法，父类代码块，子类代码块，子类构造，子类静态代码块。这六个对象的执行顺序" class="headerlink" title="11、创建一个子类对象，请写出：父类静态代码块，父类构造方法，父类代码块，子类代码块，子类构造，子类静态代码块。这六个对象的执行顺序"></a>11、创建一个子类对象，请写出：父类静态代码块，父类构造方法，父类代码块，子类代码块，子类构造，子类静态代码块。这六个对象的执行顺序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 父类静态代码块</span><br><span class="line">2  子类静态代码块</span><br><span class="line">3 父类实例代码块</span><br><span class="line">4 父类构造方法</span><br><span class="line">5 子类实例代码块</span><br><span class="line">6 子类构造方法</span><br></pre></td></tr></table></figure>

<h1 id="12、抽象类和接口的区别"><a href="#12、抽象类和接口的区别" class="headerlink" title="12、抽象类和接口的区别"></a>12、抽象类和接口的区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、抽象类继承Object，接口不是 </span><br><span class="line">2、抽象类有构造方法，接口没有</span><br><span class="line">3、抽象类可以声明成员变量和静态常量，接口只能声明静态常量</span><br><span class="line">4、抽象类可以声明成员方法，抽象方法，接口可以声明抽象方法和静态方法和默认方法(jdk1.8开始)</span><br><span class="line">5、抽象类中可以有final修饰的方法，接口不能</span><br><span class="line">6、抽象类是单继承多实现，但是接口只能继承多个其它接口</span><br></pre></td></tr></table></figure>

<h1 id="13、int和Integer有什么区别？"><a href="#13、int和Integer有什么区别？" class="headerlink" title="13、int和Integer有什么区别？"></a>13、int和Integer有什么区别？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 Integer是int的包装类；int是基本数据类型；</span><br><span class="line">2 Integer变量必须实例化后才能使用；int变量不需要；</span><br><span class="line">3 Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值;</span><br><span class="line">4 Integer的默认值是null；int的默认值是0。</span><br></pre></td></tr></table></figure>

<h1 id="14、Hashtable和HashMap区别"><a href="#14、Hashtable和HashMap区别" class="headerlink" title="14、Hashtable和HashMap区别?"></a>14、Hashtable和HashMap区别?</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 继承的父类不同</span><br><span class="line">2 hashtable是线程安全的   hashmap是非线程安全的</span><br><span class="line">3 hashtable key和value都不允许null值  hashmap key和value都允许null值</span><br><span class="line">4 hashtable 数组初始长度11 扩容原数组的2倍+1  hashmap 数组初始长度是16 扩容原数组的2倍</span><br></pre></td></tr></table></figure>

<h1 id="15、什么是类？什么是对象？什么是接口？接口和类的继承有什么本质区别"><a href="#15、什么是类？什么是对象？什么是接口？接口和类的继承有什么本质区别" class="headerlink" title="15、什么是类？什么是对象？什么是接口？接口和类的继承有什么本质区别"></a>15、什么是类？什么是对象？什么是接口？接口和类的继承有什么本质区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对象：用来描述客观事物的一个实体，由一组属性和方法构成</span><br><span class="line">类：具有相同属性和方法的一组对象的集合</span><br><span class="line">接口: 包含一系列方法的声明,一个接口只有方法的特征没有方法的实现</span><br><span class="line">一个类只能继承一个父类，可以实现多个接口</span><br></pre></td></tr></table></figure>

<h1 id="16、String-s-x3D-new-String-“xyz”-创建了几个字符串对象？"><a href="#16、String-s-x3D-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="16、String s &#x3D; new String(“xyz”);创建了几个字符串对象？"></a>16、String s &#x3D; new String(“xyz”);创建了几个字符串对象？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2个对象  堆内存一个   字符串常量池一个</span><br></pre></td></tr></table></figure>

<h1 id="17、Comparable接口的用途"><a href="#17、Comparable接口的用途" class="headerlink" title="17、Comparable接口的用途"></a>17、Comparable接口的用途</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparable接口里面有一个compareTo()方法。当一个类需要比较的时候，需自行实现Comparable接口的CompareTo方法。当调用集合排序方法的时候，就会调用对象的compareTo()方法来实现对象的比较。</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList存储学生对象-如何排序"><a href="#ArrayList存储学生对象-如何排序" class="headerlink" title="ArrayList存储学生对象 如何排序"></a>ArrayList存储学生对象 如何排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学生类实现Comparable接口 重写compareTo方法，当集合排序时，会调用当前对象的compareTo方法和其他对象进行比较</span><br></pre></td></tr></table></figure>

<h1 id="comparable和comparator接口的用途？列出他们的区别？"><a href="#comparable和comparator接口的用途？列出他们的区别？" class="headerlink" title="comparable和comparator接口的用途？列出他们的区别？"></a>comparable和comparator接口的用途？列出他们的区别？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先这两个接口一般都是用来实现集合内的排序，comparable也可以用于两个对象大小的比较。</span><br><span class="line">Comparable接口在java.lang包下面。里面有一个compareTo(T)接口方法。当一个类需要比较的时候，需自行实现Comparable接口的CompareTo方法。当调用集合排序方法的时候，就会调用对象的compareTo()方法来实现对象的比较。</span><br><span class="line">Comparator接口在java.util包下面。Comparator是一个比较器接口，一般单独定义一个比较器实现该接口中的比较方法compare();在集合sort方法中传入对应的比较器实现类。一般使用匿名内部类来实现比较器。</span><br><span class="line">Comparator相对于Comparable来说更加的灵活，耦合度低。</span><br></pre></td></tr></table></figure>



<h1 id="18、Overload-和-Override-的区别，Overload方法是否可以改变返回值的类型？"><a href="#18、Overload-和-Override-的区别，Overload方法是否可以改变返回值的类型？" class="headerlink" title="18、Overload 和 Override 的区别，Overload方法是否可以改变返回值的类型？"></a>18、Overload 和 Override 的区别，Overload方法是否可以改变返回值的类型？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法重载</span><br><span class="line">    1 方法名相同</span><br><span class="line">    2 参数项不同(参数个数 参数数据类型 参数声明顺序)</span><br><span class="line">    与访问修饰符 返回值类型无关</span><br><span class="line">方法重写</span><br><span class="line">    1 子类重写方法的访问修饰符不能严于父类</span><br><span class="line">    2 子类重写方法的返回值类型和父类一致</span><br><span class="line">    3 子类重写方法的方法名和父类一致</span><br><span class="line">    4 子类重写方法的参数列表和父类一致</span><br><span class="line"></span><br><span class="line">Overload方法可以改变返回值的类型</span><br></pre></td></tr></table></figure>

<h1 id="19、二分查找法"><a href="#19、二分查找法" class="headerlink" title="19、二分查找法"></a>19、二分查找法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="type">int</span> min=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(min+max)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid]==value)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;value)&#123;</span><br><span class="line">            max=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;value)&#123;</span><br><span class="line">            min=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(min&gt;max)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="20、String-StringBuffer-StringBuilder区别"><a href="#20、String-StringBuffer-StringBuilder区别" class="headerlink" title="20、String  StringBuffer StringBuilder区别"></a>20、String  StringBuffer StringBuilder区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 String是不可变的 对String类的任何改变都会返回一个新的String对象</span><br><span class="line">   StringBuffer是可变的，对StringBuffer的内容修改都是当前这个对象</span><br><span class="line">2 String类重写了Object类的equals方法和hashcode方法</span><br><span class="line">   StringBuffer没有重写equals方法</span><br><span class="line">3 String创建的字符串保存在字符串常量池，StringBuffer在堆中创建对象</span><br><span class="line">4 StringBuffer是线程安全的  StringBuilder是非线程安全的</span><br><span class="line">附加：</span><br><span class="line">    5、String底层是final修饰的字符数组</span><br><span class="line">   	   StringBuffer底层是普通的字符数组</span><br></pre></td></tr></table></figure>

<h1 id="String常用方法："><a href="#String常用方法：" class="headerlink" title="String常用方法："></a>String常用方法：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int length(); 得到字符串的字符个数</span><br><span class="line">char charAt(值); 返回值为char类型 从字符串中取出指定位置的字符</span><br><span class="line">char  toCharArray();　返回值为 char 数组类型。将字符串变成一个字符数组</span><br><span class="line">int indexOf(&quot;字符&quot;)  找一个指定的字符串是否存在，返回的是字符串的位置，如果不存在，则返回-1 。</span><br><span class="line">toUpperCase()；  toLowerCase()；字符串大小写的转换</span><br><span class="line">String[] split(&quot;字符&quot;)根据给定的正则表达式的匹配来拆分此字符串。形成一个新的String数组。</span><br><span class="line">boolean equals(Object anObject)比较两个字符串是否相等，返回布尔值</span><br><span class="line">trim();　　去掉字符串左右空格　　replace(char oldChar,char newChar);新字符替换旧字符，</span><br></pre></td></tr></table></figure>



<h1 id="21、给定两个一维字符串数组a和b，要求除去a中包含b中元素的项，得到数组c。说明：a和b中都可能存在为null的元素。"><a href="#21、给定两个一维字符串数组a和b，要求除去a中包含b中元素的项，得到数组c。说明：a和b中都可能存在为null的元素。" class="headerlink" title="21、给定两个一维字符串数组a和b，要求除去a中包含b中元素的项，得到数组c。说明：a和b中都可能存在为null的元素。"></a>21、给定两个一维字符串数组a和b，要求除去a中包含b中元素的项，得到数组c。说明：a和b中都可能存在为null的元素。</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">例如给定的数组为：  </span><br><span class="line">String a[] = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;c&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;d&quot;</span>&#125;;</span><br><span class="line">String b[] = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="literal">null</span>&#125;;</span><br><span class="line"></span><br><span class="line">那么得到的数组C应为：&#123;<span class="string">&quot;b&quot;</span>,<span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">String a[] = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;c&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;d&quot;</span>&#125;;</span><br><span class="line">String b[] = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="literal">null</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt;  list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String s1 : a) &#123;</span><br><span class="line">    <span class="type">boolean</span> flag=<span class="literal">true</span>;<span class="comment">//默认s1是a数组独有的</span></span><br><span class="line">    <span class="keyword">for</span> (String s2 : b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1==s2)&#123;</span><br><span class="line">            <span class="comment">//字符串常量池  &quot;a&quot;==&quot;a&quot; 比较内存地址   0x123==0x123  true</span></span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">        list.add(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<h1 id="22、输入一个字符串-通过递归-返回逆序字符串"><a href="#22、输入一个字符串-通过递归-返回逆序字符串" class="headerlink" title="22、输入一个字符串  通过递归 返回逆序字符串"></a>22、输入一个字符串  通过递归 返回逆序字符串</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">daoXu</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> daoXu(s.substring(<span class="number">1</span>))+s.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="23、输入一个字符串-比如-String-s-x3D-”aabbbc”-求字符串中每个字符的出现次数"><a href="#23、输入一个字符串-比如-String-s-x3D-”aabbbc”-求字符串中每个字符的出现次数" class="headerlink" title="23、输入一个字符串 比如 String s&#x3D;”aabbbc” 求字符串中每个字符的出现次数"></a>23、输入一个字符串 比如 String s&#x3D;”aabbbc” 求字符串中每个字符的出现次数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;aabbbc&quot;</span>;</span><br><span class="line">Map&lt;String,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">char</span>[] array = s.toCharArray();<span class="comment">// </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.get(c+<span class="string">&quot;&quot;</span>)==<span class="literal">null</span>)&#123;</span><br><span class="line">        map.put(c+<span class="string">&quot;&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        map.put(c+<span class="string">&quot;&quot;</span>,map.get(c+<span class="string">&quot;&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">    System.out.println(key+<span class="string">&quot;出现&quot;</span>+map.get(key)+<span class="string">&quot;次。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="24、递归查找指定目录所有文件-输出文件名"><a href="#24、递归查找指定目录所有文件-输出文件名" class="headerlink" title="24、递归查找指定目录所有文件  输出文件名"></a>24、递归查找指定目录所有文件  输出文件名</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">show</span><span class="params">(File file)</span>&#123;</span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ! f.isFile())&#123;</span><br><span class="line">            show(f);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="25、使用字节流将c-x2F-1-txt-复制到d-x2F-2-txt"><a href="#25、使用字节流将c-x2F-1-txt-复制到d-x2F-2-txt" class="headerlink" title="25、使用字节流将c:&#x2F;1.txt 复制到d:&#x2F;2.txt"></a>25、使用字节流将c:&#x2F;1.txt 复制到d:&#x2F;2.txt</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;c:/1.txt&quot;</span>);</span><br><span class="line">FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:/2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] b=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="keyword">while</span> ( (temp=fis.read(b)) !=-<span class="number">1</span> )&#123;</span><br><span class="line">         fos.write(b,<span class="number">0</span>,temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">fos.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="26、字节流有哪些-缓冲流的加速方式"><a href="#26、字节流有哪些-缓冲流的加速方式" class="headerlink" title="26、字节流有哪些? 缓冲流的加速方式"></a>26、字节流有哪些? 缓冲流的加速方式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InputStream</span><br><span class="line">FileInputStream</span><br><span class="line">BufferedInputStream</span><br><span class="line">ObjectInputStream</span><br><span class="line">OutputStream</span><br><span class="line">FileOutputStream</span><br><span class="line">BufferedOutputStream</span><br><span class="line">ObjectOutputStream</span><br><span class="line"></span><br><span class="line">缓冲流内置了默认大小的数组</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="27、多线程有几种实现方式-你推荐哪一种"><a href="#27、多线程有几种实现方式-你推荐哪一种" class="headerlink" title="27、多线程有几种实现方式?你推荐哪一种"></a>27、多线程有几种实现方式?你推荐哪一种</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 继承Thread类</span><br><span class="line">2 实现Runnable接口</span><br><span class="line">3 实现Callable接口</span><br><span class="line">4 线程池</span><br><span class="line">推荐使用线程池 因为线程池里面的线程可以循环使用。</span><br></pre></td></tr></table></figure>

<h1 id="28、synchronized和Lock锁两者区别："><a href="#28、synchronized和Lock锁两者区别：" class="headerlink" title="28、synchronized和Lock锁两者区别："></a>28、synchronized和Lock锁两者区别：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.首先synchronized是java内置关键字，Lock是个java接口；</span><br><span class="line">2.synchronized会自动释放锁,Lock需要调用unlock()方法手动释放锁</span><br><span class="line">3.用synchronized关键字修饰的同步代码，如果线程1获得对象锁，线程2会一直等待</span><br><span class="line">而Lock接口锁定的同步代码，如果线程1获得对象锁，线程2尝试获取不到锁的话，线程2可以不用一直等待。</span><br><span class="line">4.Lock锁适合大量代码的同步问题，synchronized锁适合少量代码的同步问题。</span><br></pre></td></tr></table></figure>

<h1 id="产生多线程死锁的必要条件及解决方法"><a href="#产生多线程死锁的必要条件及解决方法" class="headerlink" title="产生多线程死锁的必要条件及解决方法"></a>产生多线程死锁的必要条件及解决方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">死锁产生的根本原因是资源竞争。如果若干个线程正常运行，遇到彼此需要对方占有的资源时，就可能产生线程死锁.</span><br><span class="line">死锁产生的条件包括以下4点：</span><br><span class="line">	资源互斥：即资源仅能让一个线程使用而不支持多个线程同时使用。</span><br><span class="line">    请求保持：已经拥有资源的线程在请求其他资源时并没有释放当前资源。</span><br><span class="line">    不能剥夺：已经获得的资源在自主释放前不能使用其他手段剥夺。</span><br><span class="line">    循环等待：各个线程对资源的需求构成了一个循环。</span><br><span class="line">解决方法：</span><br><span class="line">	破坏循环等待是最有效的解决死锁的方法。</span><br></pre></td></tr></table></figure>

<h1 id="29、什么是java序列化-如何实现java序列化"><a href="#29、什么是java序列化-如何实现java序列化" class="headerlink" title="29、什么是java序列化?如何实现java序列化"></a>29、什么是java序列化?如何实现java序列化</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">序列化（ObjectOutputStream）可以将内存中Java对象写在硬盘上，反序列化（ObjectInputStream）就是将硬盘的内容读取到内存中重新构建对象；java是通过实现序列化接口</span><br><span class="line">(Serializable接口) 实现的序列化.</span><br></pre></td></tr></table></figure>

<h1 id="30、兔子递归"><a href="#30、兔子递归" class="headerlink" title="30、兔子递归"></a>30、兔子递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(<span class="type">int</span> month)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(month==<span class="number">1</span> || month==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getNum(month-<span class="number">1</span>)+getNum(month-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="31、插入排序"><a href="#31、插入排序" class="headerlink" title="31、插入排序"></a>31、插入排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums=&#123;<span class="number">17</span>,<span class="number">3</span>,<span class="number">20</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;nums.length ; i++) &#123;</span><br><span class="line">    <span class="type">int</span> insertValue=nums[i];<span class="comment">//待插入的值 也就是无序列表的第一个值</span></span><br><span class="line">    <span class="type">int</span> insertIndex=i-<span class="number">1</span>;<span class="comment">//待比较值的下标  初始值是有序列表最后一个值的下标</span></span><br><span class="line">    <span class="keyword">while</span> (insertIndex&gt;=<span class="number">0</span>&amp;&amp;insertValue&lt;nums[insertIndex])&#123;</span><br><span class="line">        nums[insertIndex+<span class="number">1</span>]=nums[insertIndex];</span><br><span class="line">        insertIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[insertIndex+<span class="number">1</span>]=insertValue;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(nums));</span><br></pre></td></tr></table></figure>

<h1 id="32、java中创建对象的方式"><a href="#32、java中创建对象的方式" class="headerlink" title="32、java中创建对象的方式"></a>32、java中创建对象的方式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">调用构造方法：</span><br><span class="line">    new对象</span><br><span class="line">    反射</span><br><span class="line">不调用构造方法：</span><br><span class="line">    反序列化   Object  clone()</span><br><span class="line">    克隆</span><br></pre></td></tr></table></figure>

<h1 id="33、创建Class对象的3种方式"><a href="#33、创建Class对象的3种方式" class="headerlink" title="33、创建Class对象的3种方式"></a>33、创建Class对象的3种方式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 Class.forName(&quot;类的完整路径&quot;)</span><br><span class="line">2 类型.class</span><br><span class="line">3 对象.getClass()</span><br></pre></td></tr></table></figure>

<h1 id="34、如何实现线程安全的HashMap"><a href="#34、如何实现线程安全的HashMap" class="headerlink" title="34、如何实现线程安全的HashMap"></a>34、如何实现线程安全的HashMap</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有2种办法让HashMap线程安全，分别如下：</span><br><span class="line">　　方法一：通过Collections.synchronizedMap()返回一个新的Map，这个新的map就是线程安全的。 这个要求大家习惯基于接口编程，因为返回的并不是HashMap，而是一个Map的实现。</span><br><span class="line">　　方法二：重新改写了HashMap，具体的可以查看java.util.concurrent.ConcurrentHashMap. 这个方法比方法一有了很大的改进。</span><br></pre></td></tr></table></figure>

<h1 id="ConcurrentHashMap实现原理"><a href="#ConcurrentHashMap实现原理" class="headerlink" title="ConcurrentHashMap实现原理"></a>ConcurrentHashMap实现原理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">采用Node + CAS + Synchronized来保证并发安全进行实现，</span><br><span class="line">在JDK1.7中ConcurrentHashMap，数据结构上，首先整体上是数组+链表+红黑树的结构与HashMap保持一致，其次取消了Segment分段锁的数据结构，取而代之的是Node，Node的value和next都是由volatile关键字进行修饰，可以保证可见性。将细化的粒度从段进一步降低到节点。线程安全实现上，采用CAS+Synchronized替代Segment分段锁。</span><br><span class="line">cas是比较再交换的算法</span><br></pre></td></tr></table></figure>



<h1 id="35、oracle多表连接的分类-内连接和外连接的区别"><a href="#35、oracle多表连接的分类-内连接和外连接的区别" class="headerlink" title="35、oracle多表连接的分类  内连接和外连接的区别"></a>35、oracle多表连接的分类  内连接和外连接的区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内连接  外连接  自连接   交叉连接</span><br><span class="line">内连接会过滤不满足连接条件的记录</span><br><span class="line">外连接会把主表的所有记录显示，如果关联表没有关联记录，全部显示空</span><br></pre></td></tr></table></figure>

<h1 id="36、oracle中常用的函数-分别介绍"><a href="#36、oracle中常用的函数-分别介绍" class="headerlink" title="36、oracle中常用的函数  分别介绍"></a>36、oracle中常用的函数  分别介绍</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">聚合函数</span><br><span class="line"><span class="built_in">min</span>() 取最小值</span><br><span class="line"><span class="built_in">max</span>() 取最大值</span><br><span class="line"><span class="built_in">sum</span>() 求和</span><br><span class="line"><span class="built_in">avg</span>() 求平均值</span><br><span class="line"><span class="built_in">count</span>() 求记录总数</span><br><span class="line"></span><br><span class="line">数字格式化函数</span><br><span class="line">round(数字,保留的小数位) 数字函数，会四舍五入</span><br><span class="line">trunc(数字,截断的小数位) 数字函数，不会四舍五入，截断函数</span><br><span class="line"><span class="built_in">mod</span>() 求余数</span><br><span class="line"></span><br><span class="line">字符串函数</span><br><span class="line"><span class="built_in">upper</span>() 转大写</span><br><span class="line"><span class="built_in">lower</span>() 转小写</span><br><span class="line">concat 或者<span class="operator">||</span> 字符串连接</span><br><span class="line">substr() 字符串截取函数</span><br><span class="line">lenght() 字符串长度</span><br><span class="line">replace() 替换函数、</span><br><span class="line">ltrim()去左边空格 rtrim() 去右边空格</span><br><span class="line"></span><br><span class="line">转换函数(日期函数)</span><br><span class="line"> sysdate 返回当前系统时间,没有括号</span><br><span class="line"> to_char() 将日期转换成指定格式的字符串, 将数字格式化成指定格式的字符串</span><br><span class="line"> to_date() 将字符串转日期</span><br><span class="line"> last_day(sysdate)  返回<span class="type">date</span>日期所在月份的最后一天日期</span><br><span class="line"> </span><br><span class="line"> nvl(列名,默认值) 滤空函数</span><br><span class="line"> </span><br><span class="line"> decode() 选择函数</span><br></pre></td></tr></table></figure>



<h1 id="37、行转列-列转行"><a href="#37、行转列-列转行" class="headerlink" title="37、行转列  列转行"></a>37、行转列  列转行</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--行转列</span></span><br><span class="line"><span class="keyword">select</span> name,</span><br><span class="line"><span class="built_in">max</span>(decode(course,<span class="string">&#x27;数学&#x27;</span>,score)) 数学,</span><br><span class="line"><span class="built_in">max</span>(decode(course,<span class="string">&#x27;英语&#x27;</span>,score)) 英语,</span><br><span class="line"><span class="built_in">max</span>(decode(course,<span class="string">&#x27;语文&#x27;</span>,score)) 语文</span><br><span class="line"><span class="keyword">from</span> tb_student <span class="keyword">group</span> <span class="keyword">by</span> name;</span><br><span class="line"><span class="comment">--列转行</span></span><br><span class="line"><span class="keyword">select</span> name,<span class="string">&#x27;语文&#x27;</span> course,cn_score score <span class="keyword">from</span> tb_student2 </span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> name,<span class="string">&#x27;数学&#x27;</span> course,math_score <span class="keyword">from</span> tb_student2</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> name,<span class="string">&#x27;英语&#x27;</span> course,en_score <span class="keyword">from</span> tb_student2;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="38、oracle和mysql分页"><a href="#38、oracle和mysql分页" class="headerlink" title="38、oracle和mysql分页"></a>38、oracle和mysql分页</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">oracle分页:</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> t1.<span class="operator">*</span>,rownum rn <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student) t1 <span class="keyword">where</span> rownum<span class="operator">&lt;=</span><span class="number">6</span>) t2 <span class="keyword">where</span> t2.rn<span class="operator">&gt;</span><span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">mysql分页:</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher limit <span class="number">10</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>



<h1 id="39、oracle和mysql区别"><a href="#39、oracle和mysql区别" class="headerlink" title="39、oracle和mysql区别"></a>39、oracle和mysql区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、mysql主键支持自增长，而oracle不支持，只能通过序列达到自增效果。</span><br><span class="line">2、Mysql用limit做分页,oracle用rownum做分页</span><br><span class="line">3、Oracle和 mysql的函数不同</span><br><span class="line">4、oracle varchar2(3) 以字节为单位  mysql5.0.3开始 char varchar的数字都是以字符为单位</span><br></pre></td></tr></table></figure>

<h1 id="Mysql具有存储引擎的概念-常用MyISAM与InnoDB区别"><a href="#Mysql具有存储引擎的概念-常用MyISAM与InnoDB区别" class="headerlink" title="Mysql具有存储引擎的概念 常用MyISAM与InnoDB区别"></a>Mysql具有存储引擎的概念 常用MyISAM与InnoDB区别</h1><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">MyISAM</th>
<th align="center">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">事务处理</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">数据行锁定</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">外键约束</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">表空间大小</td>
<td align="center">较小</td>
<td align="center">较大、约2倍</td>
</tr>
</tbody></table>
<h1 id="40、查询语句执行速度很慢-如何优化"><a href="#40、查询语句执行速度很慢-如何优化" class="headerlink" title="40、查询语句执行速度很慢 如何优化"></a>40、查询语句执行速度很慢 如何优化</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1）SELECT子句中避免使用*号</span><br><span class="line">2）多表连接时，使用表别名关联字段</span><br><span class="line">3）多表连接查询时，将表与表之间的关联条件写在WHERE左边关联，WHERE右边再写过滤最大的条件</span><br><span class="line">4）FROM子句中包含多个表的情况下,将表数据最少的表放在最后，因为数据库的解析器是按照从右到左的顺序处理FROM子句中的表数据，FROM子句中写在最后的表将被最先处理</span><br><span class="line">5）模糊查询 like，like ‘关键字%’会走索引,如果使用like ‘%关键字%’ 和’%关键字’将全文索引</span><br><span class="line">6）尽可能使用exists代替in,而对于连续的数据可以使用between就不要使用in和not in</span><br><span class="line">7）单独使用Group By和Order by时，Group By和Order by的列尽可能要有索引，如果没有索引，执行过程中会产生临时表，如果Group By和Order by组合使用时如果条件列不一样，也会产生临时表降低效率。</span><br><span class="line">8）对于insert的优化，可以从三个方面入手，插入单条数据时，将数据进行有序（根据索引的顺序）插入，插入多条数据时将数据合并到一条语句中执行，例如：</span><br><span class="line">insert </span><br><span class="line">对于批量插入多条数据可以使用事务进行插入处理。</span><br></pre></td></tr></table></figure>



<h1 id="41、-数据库三大范式"><a href="#41、-数据库三大范式" class="headerlink" title="41、 数据库三大范式"></a>41、 数据库三大范式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一范式：确保每列的原子性</span><br><span class="line">第二范式：确保表中的每列，都和主键相关</span><br><span class="line">第三范式：确保每列都和主键列直接相关，而不是间接相关</span><br></pre></td></tr></table></figure>



<h1 id="42、创建表和修改表"><a href="#42、创建表和修改表" class="headerlink" title="42、创建表和修改表"></a>42、创建表和修改表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> teacher(</span><br><span class="line">tno number(<span class="number">4</span>) <span class="keyword">not</span> <span class="keyword">null</span>,<span class="comment">--设置教室编号和长度，内容不能为空</span></span><br><span class="line">tname varchar2(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>, <span class="comment">--教室姓名</span></span><br><span class="line">tid <span class="type">char</span>(<span class="number">18</span>),<span class="comment">--身份证号</span></span><br><span class="line">gender <span class="type">char</span>(<span class="number">2</span>),<span class="comment">--性别</span></span><br><span class="line">birthdate <span class="type">date</span> <span class="comment">--出生日期</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span>(</span><br><span class="line">     hiredate <span class="type">date</span>, <span class="comment">--入职日期</span></span><br><span class="line">     sal number(<span class="number">7</span>,<span class="number">2</span>), <span class="comment">--薪水</span></span><br><span class="line">     wechat varchar2(<span class="number">20</span>) <span class="comment">--微信</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 修改列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> teacher modify(tname varchar2(<span class="number">30</span>))</span><br><span class="line"><span class="comment">-- 删除列 删除单列 删除多列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">drop</span> <span class="keyword">column</span> wechat;</span><br><span class="line"><span class="comment">-- 删除多列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">drop</span>(birthdate,hiredate)</span><br></pre></td></tr></table></figure>



<h1 id="43、索引的作用？和它的优缺点是什么？"><a href="#43、索引的作用？和它的优缺点是什么？" class="headerlink" title="43、索引的作用？和它的优缺点是什么？"></a>43、索引的作用？和它的优缺点是什么？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引是一张特殊的查询表，可以加快查询速度，但是索引会减慢数据增删改的效率</span><br></pre></td></tr></table></figure>

<h1 id="44、什么样的字段适合建索引？"><a href="#44、什么样的字段适合建索引？" class="headerlink" title="44、什么样的字段适合建索引？"></a>44、什么样的字段适合建索引？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、频繁搜索的列 （where tname）</span><br><span class="line">2、经常排序、分组的列 (order by  group by)</span><br><span class="line">3、经常连接的列 (dept  teacher deptno)</span><br><span class="line">4、列的值不重复</span><br><span class="line">5、列的值不经常做修改</span><br></pre></td></tr></table></figure>

<h1 id="Oracle中创建了索引，什么样的原因可能使索引不能正常使用？"><a href="#Oracle中创建了索引，什么样的原因可能使索引不能正常使用？" class="headerlink" title="Oracle中创建了索引，什么样的原因可能使索引不能正常使用？"></a>Oracle中创建了索引，什么样的原因可能使索引不能正常使用？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、列使用is null 和is not null  列的索引会失效</span><br><span class="line">2、where子句对存在索引的列使用函数时，会使优化器忽略掉这些索引，但是把函数应用在条件上，索引可以生效</span><br><span class="line">select * from staff where trunc(birthdate) = ‘01-MAY-82’;  会忽略索引</span><br><span class="line">select * from staff where birthdate &lt; (to_date(‘01-MAY-82’) + 0.9999); 索引生效</span><br><span class="line">对于min和max函数，oracle仍然使用索引</span><br><span class="line">3、模糊查询  like &#x27;aaa%&#x27; 会用到索引</span><br><span class="line">			like &#x27;%aaa&#x27; %在前面不会使用索引</span><br><span class="line">4、where子句使用不等于操作  &lt;&gt;   !=  NOT colume&gt;=?     NOT colume&lt;=?</span><br><span class="line">5、等于和范围索引不会被合并使用   </span><br><span class="line">job和deptno都是非唯一索引，这种条件下oracle不会合并索引，它只会使用第一个索引</span><br></pre></td></tr></table></figure>



<h1 id="45、写一段jdbc代码"><a href="#45、写一段jdbc代码" class="headerlink" title="45、写一段jdbc代码"></a>45、写一段jdbc代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:oracle:thin:@127.0.0.1:1521:orcl&quot;</span>,<span class="string">&quot;ycy&quot;</span>,<span class="string">&quot;m123&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from teacher&quot;</span>;</span><br><span class="line">PreparedStatement statement=conn.prepareStatement(sql);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery();</span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tno</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;tno&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">tname</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;tname&quot;</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">birthdate</span> <span class="operator">=</span> rs.getTimestamp(<span class="string">&quot;birthdate&quot;</span>);</span><br><span class="line">    System.out.println(tno+<span class="string">&quot;==&gt;&quot;</span>+tname+<span class="string">&quot;==&gt;&quot;</span>+birthdate);</span><br><span class="line">&#125;</span><br><span class="line">rs.close();</span><br><span class="line">statement.close();</span><br><span class="line">conn.close():</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="46、PreparedStatement和Statement区别"><a href="#46、PreparedStatement和Statement区别" class="headerlink" title="46、PreparedStatement和Statement区别"></a>46、PreparedStatement和Statement区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 PreparedStatement是预编译的sql语句</span><br><span class="line">2 PreparedStatement可以防止sql注入</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="47、tomcat服务器文件夹下有哪些子文件夹，每个子文件夹的作用"><a href="#47、tomcat服务器文件夹下有哪些子文件夹，每个子文件夹的作用" class="headerlink" title="47、tomcat服务器文件夹下有哪些子文件夹，每个子文件夹的作用"></a>47、tomcat服务器文件夹下有哪些子文件夹，每个子文件夹的作用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bin：存放各种平台下用于启动和停止Tomcat的脚本文件</span><br><span class="line">conf: 存放Tomcat服务器的各种配置文件</span><br><span class="line">lib:  存放Tomcat服务器所需的各种jar文件</span><br><span class="line">logs: 存放Tomcat的日志文件</span><br><span class="line">temp: Tomcat运行时用于存放临时文件</span><br><span class="line">webapps: 当发布web应用时，默认情况下会将web应用的文件存放于此目录中</span><br><span class="line">work: Tomcat把由JSP生成的Servlet放于此目录下</span><br></pre></td></tr></table></figure>



<h1 id="48、一个web项目的基本目录结构"><a href="#48、一个web项目的基本目录结构" class="headerlink" title="48、一个web项目的基本目录结构"></a>48、一个web项目的基本目录结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hello项目名</span><br><span class="line">--xxx.html</span><br><span class="line">--xxx.js</span><br><span class="line">--xxx.css</span><br><span class="line">--xxx.jsp</span><br><span class="line">--WEB-INF(这个目录下的资源，浏览器不能直接访问)</span><br><span class="line">     --lib(存放项目用到的所有jar包)</span><br><span class="line">     --classes(存放java文件编译的class文件)</span><br><span class="line">     --web.xml(web项目的配置文件)</span><br></pre></td></tr></table></figure>

<h1 id="49、request对象的常用方法"><a href="#49、request对象的常用方法" class="headerlink" title="49、request对象的常用方法"></a>49、request对象的常用方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">request是jsp内置对象 属于HttpServletRequest类型 封装了浏览器提交到服务器的所有请求数据</span><br><span class="line">1、获取请求行的请求方式</span><br><span class="line">	String method = request.getMethod();</span><br><span class="line">2、获取请求行的请求资源路径uri</span><br><span class="line">	String requestURI = request.getRequestURI();</span><br><span class="line">3、获取完整的请求url</span><br><span class="line">	String requestURL = request.getRequestURL.toString();</span><br><span class="line">4、获取请求头</span><br><span class="line">	String userInfo = request.getHeader(&quot;User-Agent&quot;);</span><br><span class="line">5、获取请求体</span><br><span class="line">	String username = request.getParameter(&quot;username&quot;);</span><br><span class="line">6、获取一组相同key的属性</span><br><span class="line">	String[] hobbies = request.getParameterValues(&quot;hobby&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="50、jsp9大内置对象（-常问）："><a href="#50、jsp9大内置对象（-常问）：" class="headerlink" title="50、jsp9大内置对象（********常问）："></a>50、jsp9大内置对象（********常问）：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1、out(JspWriter):用来向客户端发送文本数据</span><br><span class="line">  方法：print 向客户端打印数据（将各种类型的数据转换成字符串）</span><br><span class="line">	write 向客户端打印数据（字符、字符数组、字符串）</span><br><span class="line">	println 向客户端打印数据（将鄂中类型的数据转换成字符串）并换行</span><br><span class="line">2、config(ServletConfig):对应Servlet中的ServletConfig</span><br><span class="line">3、page：当前jsp页面</span><br><span class="line">4、pageContext(PageContext):代表page域的域对象</span><br><span class="line">5、exception(Throwable):只有在错误页面中可以使用这个对象</span><br><span class="line">6、request(HttpServletRequest):请求对象</span><br><span class="line">  方法：</span><br><span class="line">   	setCharacterEncoding() (设置的是request内部保存数据的编码格式，不包括rul编码格式)。</span><br><span class="line">	getParameter(“userName”)   从请求体中获取指定的数据</span><br><span class="line">	getParameterValues(“no1”) (返回的是一个数组对象)</span><br><span class="line">7、response(HttpServletResponse):响应对象</span><br><span class="line">  方法：sendRedirect(String location) (页面重定向)</span><br><span class="line">	RequestDispatcher对象的forward()方法   转发</span><br><span class="line">8、application(ServletContext):代表整个web应用的域对象</span><br><span class="line">  方法：String getRealPath(String path) 返回相对路径的真实路径</span><br><span class="line">	Object getAttribute(String key) 通过key获取对象值</span><br><span class="line">9、session(HttpSession)：代表一次会话的域对象</span><br><span class="line">  方法：setAsetAttribute(String key,Object value)：以key/value的形式保存对象值</span><br><span class="line">	getAttribute（String key）：通过key获取对象值</span><br><span class="line">	setMaxInactiveInterval（）：设定session的非活动时间 单位是秒</span><br><span class="line">	invalidate（）：设置session对象失效</span><br></pre></td></tr></table></figure>



<h1 id="51、jsp执行过程"><a href="#51、jsp执行过程" class="headerlink" title="51、jsp执行过程"></a>51、jsp执行过程</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsp先翻译成java文件 再编译成class文件 最后执行</span><br></pre></td></tr></table></figure>

<h1 id="52、get和post区别"><a href="#52、get和post区别" class="headerlink" title="52、get和post区别"></a>52、get和post区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 get提交数据在地址栏  post在请求体</span><br><span class="line">2 get不安全 post安全</span><br><span class="line">3 get只能提交少量数据  post可以提交大量数据</span><br><span class="line">4 get代表从服务器查询数据  post代表向服务器新增数据</span><br></pre></td></tr></table></figure>

<h1 id="53、转发和重定向区别"><a href="#53、转发和重定向区别" class="headerlink" title="53、转发和重定向区别"></a>53、转发和重定向区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 转发一次请求  重定向两次请求</span><br><span class="line">2 转发地址栏不会变  重定向地址栏会变</span><br><span class="line">3 转发只能访问内部资源  重定向可以访问外部资源</span><br><span class="line">4 转发性能优于重定向</span><br><span class="line"></span><br><span class="line">项目访问路径：request.getContextPath()</span><br><span class="line">转发时写的路径，默认前面会加上项目访问路径 也就是  /aaa   所以转发路径不用写项目的虚拟路径直接写web下的文件夹</span><br><span class="line">重定向写的路径就需要加上项目访问路径</span><br></pre></td></tr></table></figure>

<h1 id="54、当我在地址栏输入URL回车后-发生了什么"><a href="#54、当我在地址栏输入URL回车后-发生了什么" class="headerlink" title="54、当我在地址栏输入URL回车后 发生了什么"></a>54、当我在地址栏输入URL回车后 发生了什么</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、url经过域名解析得到服务器的ip地址</span><br><span class="line">2、通过tcp的3次握手与服务器建立连接</span><br><span class="line">3、通过http协议将请求数据发送到服务器</span><br><span class="line">4、服务器处理完请求也是通过http协议将响应数据传递给浏览器</span><br><span class="line">5、通过tcp的4次挥手将客户端和服务器端的连接断开</span><br></pre></td></tr></table></figure>

<h3 id="TCP-HTTP-协议-UDP-协议"><a href="#TCP-HTTP-协议-UDP-协议" class="headerlink" title="TCP  HTTP 协议  UDP 协议"></a>TCP  HTTP 协议  UDP 协议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP是面向连接的通信协议，通过三次握手建立连接，通过tcp的4次挥手将客户端和服务器端的连接断开</span><br><span class="line">http协议其实就是超文本传输协议，</span><br><span class="line">UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。</span><br></pre></td></tr></table></figure>

<h1 id="55、request-getAttribute-和-request-getParameter-有何区别"><a href="#55、request-getAttribute-和-request-getParameter-有何区别" class="headerlink" title="55、request.getAttribute() 和 request.getParameter() 有何区别"></a>55、request.getAttribute() 和 request.getParameter() 有何区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request.getAttribute()是根据属性名从request域对象中获取对应的属性值</span><br><span class="line">request.getParameter()是从浏览器提交的请求数据取值</span><br><span class="line"></span><br><span class="line">相同点：获取不存在的key值都是返回null</span><br></pre></td></tr></table></figure>

<h1 id="56、什么是cookie-cookie的作用-（一般不问）"><a href="#56、什么是cookie-cookie的作用-（一般不问）" class="headerlink" title="56、什么是cookie  cookie的作用 （一般不问）"></a>56、什么是cookie  cookie的作用 （一般不问）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cookie是一段文本，由服务器创建，浏览器保存，当浏览器每次请求服务器，都会将cookie归还服务器，由服务器使用。</span><br><span class="line">作用：</span><br><span class="line">    免登录</span><br><span class="line">    显示上一次访问时间</span><br><span class="line">    历史记录</span><br></pre></td></tr></table></figure>

<h1 id="57、-session的原理"><a href="#57、-session的原理" class="headerlink" title="57、 session的原理"></a>57、 session的原理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session是依赖Cookie实现的服务器端对象</span><br><span class="line">当用户第一次请求服务器时，服务器会创建session，并创建一个Cookie，在Cookie中保存了session的id，发送给客户端。</span><br><span class="line">当用户第二次访问服务器时，会在请求中把保存了sessionId的Cookie发送给服务器，服务器通过sessionId查找session对象，然后可以直接使用。也就是说，只要浏览器容器不关闭，无论访问服务器多少次，使用的都是同一个session对象。这样也就可以让多个请求共享同一个session了。</span><br></pre></td></tr></table></figure>

<h1 id="58、session和cookie的区别"><a href="#58、session和cookie的区别" class="headerlink" title="58、session和cookie的区别"></a>58、session和cookie的区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、session数据安全 cookie数据相对不安全</span><br><span class="line">2、session数据存在服务器 cookie存在客户端浏览器</span><br><span class="line">3、session可以存大量的数据 cookie大小有限制 一个cookie最大4kb</span><br></pre></td></tr></table></figure>

<h1 id="59、servlet生命周期-load-on-startup的作用"><a href="#59、servlet生命周期-load-on-startup的作用" class="headerlink" title="59、servlet生命周期 load-on-startup的作用"></a>59、servlet生命周期 load-on-startup的作用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 当浏览器第一次请求servlet时，服务器会自动创建servlet对象，然后继续调用init方法进行对象初始化</span><br><span class="line">init方法调用一次   servlet是单例的</span><br><span class="line">2 浏览器每次请求servlet，service方法就会执行一次，处理浏览器请求</span><br><span class="line">3 当服务器关闭时，会调用一次destroy释放资源</span><br><span class="line"></span><br><span class="line">当load-on-startup取值&gt;=0时，服务器启动时就创建servlet对象</span><br></pre></td></tr></table></figure>

<h1 id="60、cookie完成5分钟免登录-只需要月考之前背-（一般不问）"><a href="#60、cookie完成5分钟免登录-只需要月考之前背-（一般不问）" class="headerlink" title="60、cookie完成5分钟免登录(只需要月考之前背)（一般不问）"></a>60、cookie完成5分钟免登录(只需要月考之前背)（一般不问）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//login.jsp</span></span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span> (cookies!=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (Cookie c : cookies) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;username&quot;</span>.equals(c.getName()))&#123;</span><br><span class="line">            response.sendRedirect(request.getContextPath()+<span class="string">&quot;/request/index.jsp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dologin.jsp</span></span><br><span class="line">request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">unlogin</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;unlogin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(username)&amp;&amp;<span class="string">&quot;m123&quot;</span>.equals(pwd))&#123;</span><br><span class="line">    <span class="comment">//用户名和密码正确</span></span><br><span class="line">    <span class="keyword">if</span>(unlogin!=<span class="literal">null</span>)&#123;</span><br><span class="line">        Cookie cookie=<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">        cookie.setMaxAge(<span class="number">60</span>*<span class="number">5</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//登录成功一定是通过重定向去index.jsp</span></span><br><span class="line">    response.sendRedirect(request.getContextPath()+<span class="string">&quot;/request/index.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="61、jsp页面传递数据的方式"><a href="#61、jsp页面传递数据的方式" class="headerlink" title="61、jsp页面传递数据的方式?"></a>61、jsp页面传递数据的方式?</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 form表单 2  域对象  3 超链接  4  cookie  5 &lt;jsp:param&gt;</span><br></pre></td></tr></table></figure>

<h1 id="62、jsp-四大域和每个域数据的使用范围"><a href="#62、jsp-四大域和每个域数据的使用范围" class="headerlink" title="62、jsp 四大域和每个域数据的使用范围"></a>62、jsp 四大域和每个域数据的使用范围</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">page域   数据只能在当前页面使用</span><br><span class="line">request域  数据在一次请求中使用</span><br><span class="line">session域   数据在一次会话中使用</span><br><span class="line">application域 数据在整个web应用都可以使用</span><br></pre></td></tr></table></figure>

<h1 id="63、tomcat容器是如何创建servlet类实例？用到了什么原理？-一般不问"><a href="#63、tomcat容器是如何创建servlet类实例？用到了什么原理？-一般不问" class="headerlink" title="63、tomcat容器是如何创建servlet类实例？用到了什么原理？(一般不问)"></a>63、tomcat容器是如何创建servlet类实例？用到了什么原理？(一般不问)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 xml文件进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过 反射的方式实例化</span><br></pre></td></tr></table></figure>

<h1 id="64、JDBC中的CLOB和BLOB数据类型是什么-一般不问"><a href="#64、JDBC中的CLOB和BLOB数据类型是什么-一般不问" class="headerlink" title="64、JDBC中的CLOB和BLOB数据类型是什么 (一般不问)"></a>64、JDBC中的CLOB和BLOB数据类型是什么 (一般不问)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符大对象（CLOB）是由具有关联代码页的单字节字符组成的字符串。此数据类型适用于存储面向文本的信息，最大容量4G</span><br><span class="line">二进制大对象（BLOB）是由字节组成的二进制字符串，没有关联的代码页。此数据类型适用于存储图像，语音，图形和其他类型的业务数据。最大容量4G</span><br></pre></td></tr></table></figure>

<h1 id="65、jsp静态包含和动态包含的区别"><a href="#65、jsp静态包含和动态包含的区别" class="headerlink" title="65、jsp静态包含和动态包含的区别"></a>65、jsp静态包含和动态包含的区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include指令是静态包含  会将多个jsp合并成一个jsp,翻译成一个java文件，编译成一个class文件</span><br><span class="line">include标签是动态包含 将每个jsp各自生成java文件，编译成class文件，然后在当前jsp调用另外一个jsp</span><br></pre></td></tr></table></figure>

<h1 id="66、jsp-9大内置对象"><a href="#66、jsp-9大内置对象" class="headerlink" title="66、jsp 9大内置对象"></a>66、jsp 9大内置对象</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">out（JspWriter）：用来向客户端发送文本数据；</span><br><span class="line">config（ServletConfig）：对应Servlet中的ServletConfig；</span><br><span class="line">page ：当前JSP页面</span><br><span class="line">pageContext（PageContext）：代表page域的域对象；</span><br><span class="line">exception（Throwable）：只有在错误页面中可以使用这个对象；</span><br><span class="line">request（HttpServletRequest）：请求对象；</span><br><span class="line">response（HttpServletResponse）：响应对象；</span><br><span class="line">application（ServletContext）：代表整个web应用的域对象；</span><br><span class="line">session（HttpSession）：代表一次会话的域对象</span><br></pre></td></tr></table></figure>

<h1 id="67、（一般不问）连接池是什么？-它的好处是什么"><a href="#67、（一般不问）连接池是什么？-它的好处是什么" class="headerlink" title="67、（一般不问）连接池是什么？ 它的好处是什么"></a>67、（一般不问）连接池是什么？ 它的好处是什么</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">连接池是装有连接的容器，使用连接的话，可以从连接池中进行获取，使用完成之后将连接归还给连接池</span><br><span class="line">优点: </span><br><span class="line">连接对象创建和销毁是需要耗费时间的，由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。</span><br></pre></td></tr></table></figure>

<h1 id="68、装饰者模式"><a href="#68、装饰者模式" class="headerlink" title="68、装饰者模式"></a>68、装饰者模式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">是你   还有你   一切拜托你</span><br><span class="line">1 装饰类和目标类继承同一个类或者实现同一个接口</span><br><span class="line">2 装饰类内部包含目标类的成员变量（父类类型）</span><br><span class="line">3 不需要增强的方法全部直接调用目标类的方法</span><br><span class="line">	需要增强的方法进行方法重写</span><br><span class="line"></span><br><span class="line">在什么地方使用过装饰者模式？</span><br><span class="line">	使用缓冲流</span><br><span class="line">	数据库连接池</span><br><span class="line">	用装饰者模式做过一个敏感字符的过滤器</span><br></pre></td></tr></table></figure>

<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</span><br><span class="line"></span><br><span class="line">在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</span><br><span class="line">pulbic class FactoryBean&#123;</span><br><span class="line">    C  c;</span><br><span class="line">    public static C getBean(String type)&#123;</span><br><span class="line">        if(type.equals(“1”))&#123;</span><br><span class="line">                c=getA();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">                c=getB();</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">	&#125;</span><br><span class="line">    public static void getA()&#123;</span><br><span class="line">        return new B();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void getB&#123;</span><br><span class="line">        return new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class  C&#123;</span><br><span class="line">&#125;</span><br><span class="line">class B extends C&#123;</span><br><span class="line">&#125;</span><br><span class="line">class A extends C&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DrinkFactory&#123;</span><br><span class="line">	Drink drink;</span><br><span class="line">	public static Drink getDrink(String type)&#123;</span><br><span class="line">		if(type == null)&#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		if(&quot;coffee&quot;.equals(type))&#123;</span><br><span class="line">			drink = new Conffee();</span><br><span class="line">		&#125;else if(&quot;milk&quot;.equals(type))&#123;</span><br><span class="line">			drink = new Milk();</span><br><span class="line">		&#125;</span><br><span class="line">		return drink;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="69、什么是mvc设计模式-每个部分使用的技术"><a href="#69、什么是mvc设计模式-每个部分使用的技术" class="headerlink" title="69、什么是mvc设计模式  每个部分使用的技术"></a>69、什么是mvc设计模式  每个部分使用的技术</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">controller 控制器 负责接收用户请求，调用视图显示数据 servlet  springmvc</span><br><span class="line">model   模型 负责处理用户请求，将结果返回控制器   hibernate  mybatis</span><br><span class="line">view  视图  负责显示数据   jsp   html</span><br></pre></td></tr></table></figure>



<h1 id="70、事务是什么-jdbc控制事务的模板"><a href="#70、事务是什么-jdbc控制事务的模板" class="headerlink" title="70、事务是什么? jdbc控制事务的模板?"></a>70、事务是什么? jdbc控制事务的模板?</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">事务可以确保一组sql语句要么全部成功，要么全部失败。</span><br><span class="line">Connection conn=DriverManager.getConnection(<span class="string">&quot;url&quot;</span>,<span class="string">&quot;用户名&quot;</span>,<span class="string">&quot;密码&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    update-<span class="number">1</span></span><br><span class="line">    update-<span class="number">2</span></span><br><span class="line">    conn.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">    conn.rollback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="71、过滤器-Filter-怎么执行的（一般不问）"><a href="#71、过滤器-Filter-怎么执行的（一般不问）" class="headerlink" title="71、过滤器(Filter)怎么执行的（一般不问）"></a>71、过滤器(Filter)怎么执行的（一般不问）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先初始化过滤器 ，然后所有的请求需要经过一个一个的过滤器，执行顺序要根据web.xml里配置的&lt;filter-mapping&gt;的位置前后执行，每个过滤器之间通过chain.doFilter连接， 最后抵达真正请求的资源</span><br></pre></td></tr></table></figure>

<h1 id="72、敏感字符过滤器"><a href="#72、敏感字符过滤器" class="headerlink" title="72、敏感字符过滤器"></a>72、敏感字符过滤器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRequest</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(request);</span><br><span class="line">        <span class="built_in">this</span>.request=request;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParameter</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;坏蛋&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> request.getParameter(name);</span><br><span class="line">        <span class="keyword">if</span> (value!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value.contains(s))&#123;</span><br><span class="line">                    value=value.replaceAll(s,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest request=(HttpServletRequest)req;</span><br><span class="line">        MyRequest myRequest=<span class="keyword">new</span> <span class="title class_">MyRequest</span>(request);</span><br><span class="line">        filterChain.doFilter(myRequest,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="73、什么是脏读-不可重复读-幻读-解决方法？"><a href="#73、什么是脏读-不可重复读-幻读-解决方法？" class="headerlink" title="73、什么是脏读  不可重复读  幻读 解决方法？"></a>73、什么是脏读  不可重复读  幻读 解决方法？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">脏读:  一个事务读取到另外一个事务未提交数据</span><br><span class="line">	将事务隔离级别设置读已提交(oracle数据库的默认隔离级别）</span><br><span class="line">不可重复读:  一个事务对同一条记录的2次读取不一致，因为另外一个事务中间对记录进行了修改</span><br><span class="line">	设置可重复读的隔离级别(mysql数据库的默认隔离级别)</span><br><span class="line">幻读: 一个事务对一张表的2次查询不一致，因为另外一个事务中间对表进行了插入或者删除</span><br><span class="line">	设置串行化的隔离级别</span><br></pre></td></tr></table></figure>



<h1 id="74、事务的四大特性是：-概念性问题–面试"><a href="#74、事务的四大特性是：-概念性问题–面试" class="headerlink" title="74、事务的四大特性是：(概念性问题–面试)"></a>74、事务的四大特性是：(概念性问题–面试)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">原子性（Atomicity）：</span><br><span class="line">    事务中所有操作是不可再分割的原子单位。</span><br><span class="line">    *事务中所有操作要么全部执行成功，要么全部执行失败。</span><br><span class="line">一致性（Consistency）：</span><br><span class="line">    *事务执行后，数据库状态与其它业务规则保持一致。</span><br><span class="line">    如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。</span><br><span class="line">隔离性（Isolation）：</span><br><span class="line">    *隔离性是指在并发操作中，不同事务之间应该隔离开来，</span><br><span class="line">    使每个并发中的事务不会相互干扰。</span><br><span class="line">持久性（Durability）：</span><br><span class="line">    *一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，</span><br><span class="line">    即使提交事务后，数据库马上崩溃，</span><br><span class="line">    在数据库重启时，也必须能保证通过某种机制恢复数据。</span><br><span class="line">    </span><br><span class="line">原子性：事务中所有操作要么全部执行成功，要么全部执行失败。</span><br><span class="line"></span><br><span class="line">一致性：事务执行后，数据库状态与其它业务规则保持一致。</span><br><span class="line">如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。</span><br><span class="line"></span><br><span class="line">隔离性：在并发操作中，不同事务之间应该隔离开来</span><br><span class="line"></span><br><span class="line">持久性：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中</span><br></pre></td></tr></table></figure>

<h1 id="75、编码过滤器（需要用语言说出来）"><a href="#75、编码过滤器（需要用语言说出来）" class="headerlink" title="75、编码过滤器（需要用语言说出来）"></a>75、编码过滤器（需要用语言说出来）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncodingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        servletRequest.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        servletResponse.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="敏感字符过滤器（需要用语言说出来）"><a href="#敏感字符过滤器（需要用语言说出来）" class="headerlink" title="敏感字符过滤器（需要用语言说出来）"></a>敏感字符过滤器（需要用语言说出来）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先定义一个类继承HttpServletRequestWrapper类</span><br><span class="line">再声明HttpServletRequest成员变量，通过构造方法赋值</span><br><span class="line">重写父类的getParameter方法，先拿到目标对象getParameter获取的原始值，过滤敏感字符，将结果返回</span><br><span class="line">再声明一个过滤器类，创建装饰类对象，对目标request进行包装，传入filterChain的doFilter方法</span><br></pre></td></tr></table></figure>



<h1 id="76、已知有两个集合，要求在jsp中通过jstl遍历用户数据和用户对应部门的数据"><a href="#76、已知有两个集合，要求在jsp中通过jstl遍历用户数据和用户对应部门的数据" class="headerlink" title="76、已知有两个集合，要求在jsp中通过jstl遍历用户数据和用户对应部门的数据"></a>76、已知有两个集合，要求在jsp中通过jstl遍历用户数据和用户对应部门的数据</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Huser属性id username password createtime did</span><br><span class="line">Hdept属性id deptName</span><br><span class="line">did是 Huser 关联Hdept的外键</span><br><span class="line">List&lt;Huser&gt; listUser=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Hdept&gt; listDept=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">数据假设已经存入集合</span><br><span class="line">request.setAttribute(<span class="string">&quot;listUser&quot;</span>,listUser);</span><br><span class="line">request.setAttribute(<span class="string">&quot;listDept&quot;</span>,listDept);</span><br><span class="line"></span><br><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;listUser&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;user&quot;</span>&gt;</span><br><span class="line">    $&#123;user.id&#125;==&gt;$&#123;user.username&#125;==&gt;</span><br><span class="line">    &lt;fmt:formatDate value=<span class="string">&quot;$&#123;user.createtime&#125;&quot;</span> pattern=<span class="string">&quot;yyyy-MM-dd&quot;</span>&gt;</span><br><span class="line">    ==&gt;</span><br><span class="line">    &lt;c:forEach items=<span class="string">&quot;$&#123;listDept&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><br><span class="line">        &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;user.did==dept.id&#125;&quot;</span> &gt;$&#123;dept.deptName&#125;&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/c:forEach&gt;  </span><br></pre></td></tr></table></figure>

<h1 id="77、跨域"><a href="#77、跨域" class="headerlink" title="77、跨域"></a>77、跨域</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果请求的url跟当前的url 协议 端口号任意一个不同，就属于跨域</span><br><span class="line">百度服务器能接收到请求，也能响应浏览器，但是浏览器拦截数据，不会显示，需要进行跨域设置（在服务器设置响应头，通知浏览器允许接收数据，不要拦截）</span><br></pre></td></tr></table></figure>

<h1 id="78、cookies、sessionStorage和localStorage解释及区别"><a href="#78、cookies、sessionStorage和localStorage解释及区别" class="headerlink" title="78、cookies、sessionStorage和localStorage解释及区别"></a>78、cookies、sessionStorage和localStorage解释及区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cookie</span><br><span class="line">Cookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</span><br><span class="line">localStorage</span><br><span class="line">localStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。</span><br><span class="line">sessionStorage</span><br><span class="line">sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会 话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>特性</th>
<th>Cookie</th>
<th align="center">localStorage</th>
<th>sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td>数据的生命期</td>
<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>
<td align="center">除非被清除，否则永久保存</td>
<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>
</tr>
<tr>
<td>存放数据大小</td>
<td>4K左右</td>
<td align="center">一般为5MB</td>
<td>一般为5MB</td>
</tr>
<tr>
<td>与服务器端通信</td>
<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>
<td align="center">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
<td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
</tr>
<tr>
<td>易用性</td>
<td>需要程序员自己封装，源生的Cookie接口不友好</td>
<td align="center">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
<td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
</tr>
</tbody></table>
<h2 id="sessionStorage的使用："><a href="#sessionStorage的使用：" class="headerlink" title="sessionStorage的使用："></a>sessionStorage的使用：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取sessionStorage对象</span></span><br><span class="line"><span class="keyword">var</span> storage = <span class="variable language_">window</span>.<span class="property">sessionStorage</span>;  </span><br><span class="line"><span class="comment">//保存数据语法：</span></span><br><span class="line">sessionStorage.<span class="title function_">setItem</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">//读取数据语法：</span></span><br><span class="line"><span class="keyword">var</span> lastname = sessionStorage.<span class="title function_">getItem</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="comment">//删除指定键的数据语法：</span></span><br><span class="line">sessionStorage.<span class="title function_">removeItem</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="comment">//删除所有数据：</span></span><br><span class="line">sessionStorage.<span class="title function_">clear</span>();</span><br></pre></td></tr></table></figure>



<h1 id="79、maven的作用"><a href="#79、maven的作用" class="headerlink" title="79、maven的作用"></a>79、maven的作用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1、依赖管理（对项目依赖的jar包进行管理）</span><br><span class="line">2、一键构建项目</span><br><span class="line"></span><br><span class="line">maven工程的目录结构</span><br><span class="line">项目名</span><br><span class="line">--src</span><br><span class="line">    -- main</span><br><span class="line">        --java (存放所有的java源码)</span><br><span class="line">        --resources (存放项目的xml配置文件)</span><br><span class="line">        --webapp (存放静态资源 css js 图片 html jsp web项目才有)</span><br><span class="line">	---test</span><br><span class="line">        -- java (存放测试类)</span><br><span class="line">        -- resources(存放测试需要的配置文件  一般为空)</span><br><span class="line">-- pom.xml 存储需要jar包的坐标.</span><br><span class="line"></span><br><span class="line">maven坐标的主要组成</span><br><span class="line">groupId：定义当前maven项目属于哪个项目</span><br><span class="line">artifactId：定义实际项目中的某一个模块</span><br><span class="line">version：定义当前项目的当前版本</span><br><span class="line">packaging：定义当前项目的打包方式</span><br><span class="line"></span><br><span class="line">bin:存放了maven 的命令，比如mvn tomcat:run</span><br><span class="line">boot:存放了一些maven 本身的引导程序，如类加载器等</span><br><span class="line">conf:存放了maven 的一些配置文件，如 setting.xml 文件</span><br><span class="line">lib:存放了maven 本身运行所需的一些jar 包</span><br><span class="line">根据这些坐标，在maven库中可以找到唯一的jar包</span><br><span class="line">maven的作用：</span><br><span class="line">依赖管理</span><br><span class="line">项目的一键构建</span><br></pre></td></tr></table></figure>

<h3 id="创建maven的web项目"><a href="#创建maven的web项目" class="headerlink" title="创建maven的web项目"></a>创建maven的web项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、pom.xml删除多余的代码</span><br><span class="line">2、补齐4个文件夹，设置文件夹类型</span><br><span class="line">3、webappp/WEB-INF/web.xml</span><br><span class="line">换跟标签的头部</span><br><span class="line"></span><br><span class="line">clean（清理）：删除整个target文件夹</span><br><span class="line"></span><br><span class="line">maven的默认生命周期 每个生命周期对应一个maven命令</span><br><span class="line">每次执行指定的生命周期命令，都会从第一个命令Compile开始，一直运行到指定命令结束</span><br><span class="line"></span><br><span class="line">Compile（编译）：</span><br><span class="line">	将src/main/java下面的所有java文件编译成class文件，将结果输出到target文件夹</span><br><span class="line">test(测试)：</span><br><span class="line">	将src/test/java下面的所有测试类编译成class文件，将结果输出到target文件夹，同时会运行测试类中所有@Test修饰的测试方法</span><br><span class="line">package（打包）</span><br><span class="line">	将整个maven工程按照pom.xml的 &lt;packaging&gt;&lt;/packaging&gt;标签配置进行打包，如果写jar，那么就打jar包，如果写war包，那么就打war包</span><br><span class="line">	一般java工程打jar包，web项目打war包</span><br><span class="line">install(安装)</span><br><span class="line">	将maven项目打包后放入本地仓库，其他项目通过坐标引入jar包</span><br></pre></td></tr></table></figure>

<h1 id="80、hibernate的开发步骤"><a href="#80、hibernate的开发步骤" class="headerlink" title="80、hibernate的开发步骤"></a>80、hibernate的开发步骤</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 加载hibernate配置文件</span></span><br><span class="line"><span class="comment">//configure() 默认读取src下的hibernate.cfg.xml</span></span><br><span class="line"><span class="comment">//src/main/java  和 src/main/resource都代表src根目录</span></span><br><span class="line"><span class="comment">//运行时会合并成一个目录</span></span><br><span class="line"><span class="type">Configuration</span> <span class="variable">configure</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure();</span><br><span class="line"><span class="comment">//2 创建SessionFactory</span></span><br><span class="line"><span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> configure.buildSessionFactory();</span><br><span class="line"><span class="comment">//3.创建session对象</span></span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="comment">//4 开启事务</span></span><br><span class="line"><span class="type">Transaction</span> <span class="variable">transaction</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"><span class="comment">//5 对数据库增删改查</span></span><br><span class="line"><span class="type">HUser</span> <span class="variable">hUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HUser</span>();</span><br><span class="line">hUser.setName(<span class="string">&quot;漂流记&quot;</span>);</span><br><span class="line">hUser.setPassword(<span class="string">&quot;m123&quot;</span>);</span><br><span class="line">hUser.setCreatetime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">session.save(hUser);</span><br><span class="line"><span class="comment">//6 提交事务</span></span><br><span class="line">transaction.commit();</span><br><span class="line"><span class="comment">//7 关闭session</span></span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure>

<h1 id="81、hibernate中get和load的区别"><a href="#81、hibernate中get和load的区别" class="headerlink" title="81、hibernate中get和load的区别"></a>81、hibernate中get和load的区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、</span><br><span class="line">get是立即查询</span><br><span class="line">load支持延迟加载，使用对象的时候查询数据库</span><br><span class="line">2、</span><br><span class="line">如果根据主键查询不到数据 get返回null load抛异常ObjectNotFoundException</span><br></pre></td></tr></table></figure>

<h1 id="82、什么是Hibernate延迟加载。"><a href="#82、什么是Hibernate延迟加载。" class="headerlink" title="82、什么是Hibernate延迟加载。"></a>82、什么是Hibernate延迟加载。</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate从数据库获取某一个对象数据时，由于没有使用该对象的数据（除标识符外），Hibernate只是为该对象创建一个代理对象，这个对象上的所有属性都为默认值；只有在真正需要使用该对象的数据时才创建这个真正的对象，真正从数据库中加载它的数据。</span><br></pre></td></tr></table></figure>

<h1 id="83、hibernate一级缓存和二级缓存"><a href="#83、hibernate一级缓存和二级缓存" class="headerlink" title="83、hibernate一级缓存和二级缓存"></a>83、hibernate一级缓存和二级缓存</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 一级缓存是session级别的缓存，同一个session发送2条相同的sql语句，第二次查询不会查询数据库，</span><br><span class="line">直接从一级缓存获取数据。</span><br><span class="line">2 二级缓存是SessionFactory级别的缓存，同一个SessionFactory打开的所有session共享一个二级缓存</span><br><span class="line">当查询数据时，先查一级缓存，如果没有数据再查二级缓存，如果还没有数据最后查询数据库。</span><br></pre></td></tr></table></figure>

<h1 id="mybatis一级缓存和二级缓存的区别"><a href="#mybatis一级缓存和二级缓存的区别" class="headerlink" title="mybatis一级缓存和二级缓存的区别"></a>mybatis<strong>一级缓存和二级缓存的区别</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一级缓存是sqlsession级别 同一个sqlsession中 发送2次相同的sql语句</span><br><span class="line">第二次不再从数据库查询 直接由一级缓存返回数据</span><br><span class="line"></span><br><span class="line">二级缓存是mapper的namespace级别 相同的namespace共享一个二级缓存</span><br><span class="line">查询数据时先查二级缓存 在查一级缓存 最后查数据库</span><br></pre></td></tr></table></figure>



<h1 id="84、hibernate查询方式"><a href="#84、hibernate查询方式" class="headerlink" title="84、hibernate查询方式"></a>84、hibernate查询方式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 oid方式</span><br><span class="line">2 hql语句</span><br><span class="line">3 sql语句</span><br><span class="line">4  qbc查询</span><br><span class="line">5 对象导航查询</span><br></pre></td></tr></table></figure>

<h1 id="85、hibernate对象的三种状态"><a href="#85、hibernate对象的三种状态" class="headerlink" title="85、hibernate对象的三种状态"></a>85、hibernate对象的三种状态</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 瞬时态(临时态) 刚刚new出来的对象</span><br><span class="line">2 持久态   通过session.save()将对象存入数据库，对象由瞬时态转换持久态</span><br><span class="line">3 游离态 通过session.close()关闭session,对象由持久态转换游离态</span><br></pre></td></tr></table></figure>

<h1 id="86、什么是悲观锁和乐观锁"><a href="#86、什么是悲观锁和乐观锁" class="headerlink" title="86、什么是悲观锁和乐观锁"></a>86、什么是悲观锁和乐观锁</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">悲观锁</span><br><span class="line">可以通过for update实现</span><br><span class="line">当一个事务获取数据时，认为其他事务会操作同一条记录，所以这个事务会对记录锁定，</span><br><span class="line">只有当这个事务提交时，其他事务才允许对记录进行操作</span><br><span class="line"></span><br><span class="line">乐观锁</span><br><span class="line">可以通过版本号version实现，</span><br><span class="line">当查询数据时，将数据版本号version一起查询，当执行update语句时，在update语句的where部分将自己的version和数据库中的version做匹配，</span><br><span class="line">匹配成功，数据库的version加1</span><br><span class="line">匹配失败，更新失败</span><br></pre></td></tr></table></figure>

<h1 id="什么是hibernate和mybatis悲观锁和乐观锁"><a href="#什么是hibernate和mybatis悲观锁和乐观锁" class="headerlink" title="什么是hibernate和mybatis悲观锁和乐观锁"></a>什么是hibernate和mybatis悲观锁和乐观锁</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">悲观锁：</span><br><span class="line">	hibernate自动在select最后生成for update</span><br><span class="line">	mybatis需要在select最后手写for update</span><br><span class="line">乐观锁</span><br><span class="line">	hibernate配置version列 version属性 version标签 在update修改时 where条件 会自动有version判断</span><br><span class="line">	mybatis配置version列 version属性 在update修改时 where条件手写version判断	</span><br></pre></td></tr></table></figure>



<h1 id="87、-mybatis-区别"><a href="#87、-mybatis-区别" class="headerlink" title="87、 mybatis  #{}   ${}区别"></a>87、 mybatis  #{}   ${}区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 #&#123;&#125; 占位符 会生成jdbc的? 避免sql注入</span><br><span class="line">2 $&#123;&#125; 拼接符 做字符串的连接 不能避免sql注入</span><br></pre></td></tr></table></figure>

<h1 id="分页流程"><a href="#分页流程" class="headerlink" title="分页流程"></a>分页流程</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">没使用框架：</span><br><span class="line">	前端传的数据是查询的页码以及每页条数</span><br><span class="line">	后台定义一个PageBean 里面数据有 1、当前页码2、每页条数3、总记录数4、总页数5、当前页数据</span><br><span class="line">	前端传到service，service传到dao，在dao中先声明pageBean对象</span><br><span class="line">	先存入当前页码和每页条数，然后查询出总记录数以及需要返回的数据，总页数会在PageBean自动计算</span><br><span class="line">	最后将pageBean对象返回</span><br><span class="line">使用mybatis框架的pagehelper的分页插件：</span><br><span class="line">	需要先导入分页插件（spring的话还需要写一个分页插件的配置文件，springboot可以直接使用）</span><br><span class="line">	前端传查询的页码以及每页条数到service</span><br><span class="line">	service先写通过PageHelper.startPage(pageNum, pageSize);设置</span><br><span class="line">	返回的时候new一个PageInfo对象，第一个参数为查询的list集合的数据，第二个参数设置页码数量，默认为8</span><br></pre></td></tr></table></figure>



<h1 id="88、mybatis动态mapper的实现原理-mapper接口中的方法能不能重载"><a href="#88、mybatis动态mapper的实现原理-mapper接口中的方法能不能重载" class="headerlink" title="88、mybatis动态mapper的实现原理?mapper接口中的方法能不能重载?"></a>88、mybatis动态mapper的实现原理?mapper接口中的方法能不能重载?</h1><h1 id="Mybatis中通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#Mybatis中通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="Mybatis中通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？？Dao接口里的方法，参数不同时，方法能重载吗？"></a>Mybatis中通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？？Dao接口里的方法，参数不同时，方法能重载吗？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</span><br><span class="line">Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</span><br></pre></td></tr></table></figure>

<h1 id="89、-mybatis的多对一和一对多如何实现？"><a href="#89、-mybatis的多对一和一对多如何实现？" class="headerlink" title="89、  mybatis的多对一和一对多如何实现？"></a>89、  mybatis的多对一和一对多如何实现？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多对一使用association标签</span><br><span class="line">一对多使用collection标签</span><br></pre></td></tr></table></figure>

<h1 id="90、Hibernate和Mybatis的区别"><a href="#90、Hibernate和Mybatis的区别" class="headerlink" title="90、Hibernate和Mybatis的区别"></a>90、Hibernate和Mybatis的区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1  Hibernate自动生成sql   Mybatis需要手写sql</span><br><span class="line">2  Hibernate数据库无关性好  mybatis无法做到数据库无关性，不同的数据库需要写不同SQL。</span><br><span class="line">3 Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。</span><br></pre></td></tr></table></figure>

<h2 id="91、动态代理区别"><a href="#91、动态代理区别" class="headerlink" title="91、动态代理区别"></a>91、动态代理区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdk动态代理（难度高） 基于接口产生代理对象</span><br><span class="line">cglib动态代理  基于目标类产生代理对象 基于子类代理</span><br></pre></td></tr></table></figure>

<h1 id="92、spring能帮我们做什么事情-什么是spring"><a href="#92、spring能帮我们做什么事情-什么是spring" class="headerlink" title="92、spring能帮我们做什么事情 (什么是spring)"></a>92、spring能帮我们做什么事情 (什么是spring)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring包含ioc和aop2大功能</span><br><span class="line">ioc是控制反转  将对象的创建交给spring容器</span><br><span class="line">di是依赖注入  给对象中的属性赋值</span><br><span class="line">常用的依赖注入有3种</span><br><span class="line">1 set注入 </span><br><span class="line">2 构造注入 </span><br><span class="line">3 注解注入 使用resource和autowired2个注解</span><br><span class="line"></span><br><span class="line">aop是面向切面编程 可以实现不修改源码的情况下给程序动态添加功能</span><br><span class="line">底层依赖于jdk动态代理和cglib动态代理，如果目标类实现了接口，优先使用jdk动态代理</span><br><span class="line">aop有5种通知</span><br><span class="line">    1 前置通知</span><br><span class="line">    2 后置通知</span><br><span class="line">    3 最终通知</span><br><span class="line">    4 异常通知</span><br><span class="line">    5 环绕通知</span><br><span class="line">可以使用aop做日志功能，将程序的运行信息记录到log日志文件</span><br></pre></td></tr></table></figure>

<h1 id="93、请写出在applicationContext-xml中创建package1-DestBean对象放入IOC容器并且注入sourceBean对象的代码-手写纸上"><a href="#93、请写出在applicationContext-xml中创建package1-DestBean对象放入IOC容器并且注入sourceBean对象的代码-手写纸上" class="headerlink" title="93、请写出在applicationContext.xml中创建package1.DestBean对象放入IOC容器并且注入sourceBean对象的代码.(手写纸上)"></a>93、请写出在applicationContext.xml中创建package1.DestBean对象放入IOC容器并且注入sourceBean对象的代码.(手写纸上)</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sourceBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;package1.SourceBean&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;destBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;package1.DestBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sourceBean&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sourceBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="94、Spring的两种代理JDK和CGLIB的区别"><a href="#94、Spring的两种代理JDK和CGLIB的区别" class="headerlink" title="94、Spring的两种代理JDK和CGLIB的区别"></a>94、Spring的两种代理JDK和CGLIB的区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP</span><br><span class="line">2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP</span><br><span class="line">3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代理模式：</span><br><span class="line">   1、代理类和目标类实现同一个接口</span><br><span class="line">   2、代理类内部声明目标类（父类类型）的成员变量</span><br><span class="line">      和增强类的成员变量</span><br><span class="line">   3、在代理对象的代理方法调用目标类的目标方法和增强类的增强方法</span><br></pre></td></tr></table></figure>

<h1 id="95、Spring中的设计模式有哪些"><a href="#95、Spring中的设计模式有哪些" class="headerlink" title="95、Spring中的设计模式有哪些"></a>95、Spring中的设计模式有哪些</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 工厂模式  	</span><br><span class="line">2. 单例模式       </span><br><span class="line">3. 适配器模式    </span><br><span class="line">4. 代理模式		</span><br><span class="line">5. 模板模式		</span><br><span class="line">6. 策略模式</span><br></pre></td></tr></table></figure>

<h1 id="96、Resource和Autowired注解的区别"><a href="#96、Resource和Autowired注解的区别" class="headerlink" title="96、Resource和Autowired注解的区别"></a>96、Resource和Autowired注解的区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Resource注解如果有name属性 将name属性的值当做对象id从spring容器中查找对象</span><br><span class="line">如果没有name属性，以属性名作为对象id查找对象，如果找不到对象，继续按照属性的类型查找</span><br><span class="line"></span><br><span class="line">Autowired注解是按照属性的类型查找</span><br></pre></td></tr></table></figure>

<h1 id="98、IOC是什么-DI是什么？"><a href="#98、IOC是什么-DI是什么？" class="headerlink" title="98、IOC是什么,DI是什么？"></a>98、IOC是什么,DI是什么？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ioc 控制反转 负责创建对象  将对象的创建权交给spring容器管理</span><br><span class="line">	di  依赖注入  负责给对象中的属性赋值</span><br><span class="line">		1 set注入</span><br><span class="line">			需要给属性提供set方法 使用set方法给属性赋值</span><br><span class="line">		2 构造注入 </span><br><span class="line">		3 注解注入  有resource和autowired 2个注解</span><br><span class="line">		4 c命名空间，p命名空间</span><br><span class="line">IOC：就是对象之间的依赖关系由容器来创建，对象之间的关系本来是由我们开发者自己创建和维护的，在我们使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做，这就是控制反转。BeanFactory接口是Spring Ioc容器的核心接口。</span><br><span class="line">DI：我们在使用Spring容器的时候，容器通过调用set方法或者是构造器来建立对象之间的依赖关系。</span><br><span class="line">控制反转是目标，依赖注入是我们实现控制反转的一种手段。		</span><br></pre></td></tr></table></figure>



<h1 id="99、-什么是aop-有几种通知"><a href="#99、-什么是aop-有几种通知" class="headerlink" title="99、 什么是aop?有几种通知?"></a>99、 什么是aop?有几种通知?</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">aop是面向切面编程，可以在不修改源代码的基础上给程序动态添加功能</span><br><span class="line">	aop底层是依赖jdk动态代理和cglib动态代理，如果目标类实现接口，优先使用jdk动态代理</span><br><span class="line">5种通知：</span><br><span class="line">    1 前置通知 在目标方法之前运行</span><br><span class="line">    2 后置通知 在目标方法之后运行</span><br><span class="line">    3 最终通知 在目标方法之后运行，发生异常最终通知也会运行</span><br><span class="line">    4 异常通知 发生异常后运行</span><br><span class="line">	5、环绕通知 等于以上4种通知</span><br><span class="line">你用aop做过什么？（日志）	最重要</span><br><span class="line">通过aop的环绕通知，在目标方法执行之前可以记录用户的请求地址 请求方式</span><br><span class="line">请求的类名和方法以及用户传递过来的请求数据以及目标方法执行的开始时间</span><br><span class="line">当目标方法执行之后，还记录了目标方法的返回结果和目标方法的结束时间</span><br><span class="line"></span><br><span class="line">定义aop的常用注解：</span><br><span class="line">@Aspect:作用是把当前类标识为一个切面供容器读取</span><br><span class="line"> </span><br><span class="line">@Pointcut：Pointcut是植入Advice的触发条件。每个Pointcut的定义包括2部分，一是表达式，二是方法签名。方法签名必须是 public及void型。可以将Pointcut中的方法看作是一个被Advice引用的助记符，因为表达式不直观，因此我们可以通过方法签名的方式为 此表达式命名。因此Pointcut中的方法只需要方法签名，而不需要在方法体内编写实际代码。</span><br><span class="line">@Around：环绕增强，相当于MethodInterceptor</span><br><span class="line">@AfterReturning：后置增强，相当于AfterReturningAdvice，方法正常退出时执行</span><br><span class="line">@Before：标识一个前置增强方法，相当于BeforeAdvice的功能，相似功能的还有</span><br><span class="line">@AfterThrowing：异常抛出增强，相当于ThrowsAdvice</span><br><span class="line">@After: final增强，不管是抛出异常或者正常退出都会执行</span><br></pre></td></tr></table></figure>

<h1 id="100、创建jdk动态代理对象"><a href="#100、创建jdk动态代理对象" class="headerlink" title="100、创建jdk动态代理对象"></a>100、创建jdk动态代理对象</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(ClassLoader classLoader,Class[] interfaces,InvocationHandler接口);</span><br><span class="line">    三个参数：</span><br><span class="line">    1、ClassLoader类加载器</span><br><span class="line">    动态代理会自动生成一个代理类，也需要加载到方法区内存 也需要ClassLoader</span><br><span class="line">    ①自动生成的代理类在磁盘上有没有对应的class文件？  没有</span><br><span class="line">    2、一组接口  Class[] interfaces</span><br><span class="line">    3、InvocationHandler接口 处理方法 当调用代理对象的所有方法时，</span><br><span class="line">    都是调用InvocationHandler的invoke()</span><br></pre></td></tr></table></figure>

<h1 id="101、-spring-mvc工作流程-参考课件"><a href="#101、-spring-mvc工作流程-参考课件" class="headerlink" title="101、 spring mvc工作流程 参考课件"></a>101、 spring mvc工作流程 参考课件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、用户发送请求至前端控制器DispatcherServlet</span><br><span class="line">2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。</span><br><span class="line">3、处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</span><br><span class="line">4、DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</span><br><span class="line">5、执行处理器(Controller，也叫后端控制器)。</span><br><span class="line">6、Controller执行完成返回ModelAndView</span><br><span class="line">7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</span><br><span class="line">8、DispatcherServlet将ModelAndView传给ViewResolver视图解析器</span><br><span class="line">9、ViewReslover解析后返回具体View</span><br><span class="line">10、DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</span><br><span class="line">11、DispatcherServlet响应用户</span><br></pre></td></tr></table></figure>

<p><img src="D:\javapx\自作笔记\java\images\javawebimg\44.png"></p>
<h1 id="102、Mybatis-如何防止-sql-注入？mybatis-拦截器了解过吗，应用场景是什么？"><a href="#102、Mybatis-如何防止-sql-注入？mybatis-拦截器了解过吗，应用场景是什么？" class="headerlink" title="102、Mybatis 如何防止 sql 注入？mybatis 拦截器了解过吗，应用场景是什么？"></a>102、Mybatis 如何防止 sql 注入？mybatis 拦截器了解过吗，应用场景是什么？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mybatis使用#&#123;&#125;防止sql注入。 </span><br><span class="line">Mybatis拦截器只能拦截四种类型的接口：Executor、StatementHandler、</span><br><span class="line">ParameterHandler和ResultSetHandler。Mybatis 可以对这四个接口中所有的方法进行拦截。</span><br><span class="line">Mybatis拦截器常常会被用来进行分页处理。 </span><br></pre></td></tr></table></figure>

<h1 id="103、fastdfs"><a href="#103、fastdfs" class="headerlink" title="103、fastdfs"></a>103、fastdfs</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件服务器，可以自己搭建使用</span><br></pre></td></tr></table></figure>

<h1 id="104、什么是Ajax和JSON，它们的优缺点？"><a href="#104、什么是Ajax和JSON，它们的优缺点？" class="headerlink" title="104、什么是Ajax和JSON，它们的优缺点？"></a>104、什么是Ajax和JSON，它们的优缺点？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ajax是异步的JavaScript和xml，用于在Web页面中实现异步数据交互，实现页面局部刷新。</span><br><span class="line">优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，避免用户不断刷新或者跳转页面，提高用户体验</span><br><span class="line"></span><br><span class="line">JSON是一种轻量级的数据交换格式</span><br><span class="line">优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字）</span><br></pre></td></tr></table></figure>

<h1 id="105、简述ajax的执行过程？"><a href="#105、简述ajax的执行过程？" class="headerlink" title="105、简述ajax的执行过程？"></a>105、简述ajax的执行过程？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 创建XMLHttpRequest对象</span><br><span class="line">2 执行open,设置请求方式,请求url,是否异步</span><br><span class="line">3 执行send发送请求</span><br><span class="line">4 绑定事件 根据请求状态(4代表已完成)和服务器响应状态(200),处理结果</span><br></pre></td></tr></table></figure>

<h1 id="106、ajax请求时，如何解释json数据"><a href="#106、ajax请求时，如何解释json数据" class="headerlink" title="106、ajax请求时，如何解释json数据?"></a>106、ajax请求时，如何解释json数据?</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用eval() 或者JSON.parse()</span><br></pre></td></tr></table></figure>

<h1 id="107、ajax的最大的特点是什么"><a href="#107、ajax的最大的特点是什么" class="headerlink" title="107、ajax的最大的特点是什么"></a>107、ajax的最大的特点是什么</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ajax可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验，还可以按需获取数据，节约带宽资源</span><br></pre></td></tr></table></figure>

<h1 id="108、Spring支持几种类型的事务管理？"><a href="#108、Spring支持几种类型的事务管理？" class="headerlink" title="108、Spring支持几种类型的事务管理？"></a>108、Spring支持几种类型的事务管理？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 编程式事务: </span><br><span class="line">对于编程式事务管理,</span><br><span class="line">简单的说就是在代码中需要直接加入处理事务的逻辑,</span><br><span class="line">可能需要在代码中显式调用beginTransaction() commit()  rollback() </span><br><span class="line">等事务管理相关的方法,如在执行a方法的时候需要事务处理,</span><br><span class="line">你需要在a方法开始时候开启事务,处理完成之后,在方法结束的时候,关闭事务.</span><br><span class="line">2 声明式事务:</span><br><span class="line">spring倡导的非侵入式的开发方式.声明式事务管理使业务代码不受污染,</span><br><span class="line">有两种常用的方式,一种是基于tx和aop命名空间的xml配置文件,</span><br><span class="line">另一种就是基于@Transactional注解. </span><br></pre></td></tr></table></figure>

<h1 id="109、spring事务传播特性有哪些？"><a href="#109、spring事务传播特性有哪些？" class="headerlink" title="109、spring事务传播特性有哪些？"></a>109、spring事务传播特性有哪些？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">required 支持当前事务，如果不存在就新建一个（默认）</span><br><span class="line">requires_new  如果有事务存在，挂起当前事务，创建一个新的事务</span><br><span class="line">supports  支持当前事务，如果不存在，就不使用事务</span><br><span class="line">not_supported以非事务方式运行，如果有事务存在，挂起当前事务</span><br><span class="line">nested如果当前事务存在，则嵌套事务执行</span><br><span class="line">mandatory支持当前事务，如果不存在，抛出异常</span><br><span class="line">never 以非事务方式执行，如果有事务存在，抛出异常</span><br></pre></td></tr></table></figure>

<h1 id="110、什么是JSONP和CORS-它们的区别是什么？"><a href="#110、什么是JSONP和CORS-它们的区别是什么？" class="headerlink" title="110、什么是JSONP和CORS,它们的区别是什么？"></a>110、什么是JSONP和CORS,它们的区别是什么？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Jsonp和CORS是用来解决跨域访问的解决方案.</span><br><span class="line">JSONP的原理是动态创建script标签, CORS是跨域资源共享，需要在服务器端设置CORS配置</span><br><span class="line">1.1. JSONP发送的不是ajax请求, CORS发送的是真正的ajax请求</span><br><span class="line">1.2. JSONP不支持post请求, CORS支持</span><br><span class="line">1.3. JSONP没有兼容问题, CORS有兼容问题,只有ie10和谷歌火狐等浏览器才支持</span><br></pre></td></tr></table></figure>

<h1 id="111、角色类Role有属性-roleId-roleName-用户类User有属性-name-age-role-写出一个List对象转换后的json字符串-集合中至少包含一个用户和一个角色"><a href="#111、角色类Role有属性-roleId-roleName-用户类User有属性-name-age-role-写出一个List对象转换后的json字符串-集合中至少包含一个用户和一个角色" class="headerlink" title="111、角色类Role有属性(roleId, roleName) , 用户类User有属性(name,age,role) 写出一个List对象转换后的json字符串. 集合中至少包含一个用户和一个角色."></a>111、角色类Role有属性(roleId, roleName) , 用户类User有属性(name,age,role) 写出一个List<User>对象转换后的json字符串. 集合中至少包含一个用户和一个角色.</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;“name”:”张三”,”age”:18, “role”: &#123;“roleId”: 1, “roleName”:”管理员”&#125;&#125;]</span><br></pre></td></tr></table></figure>

<h1 id="112、springmvc注解"><a href="#112、springmvc注解" class="headerlink" title="112、springmvc注解"></a>112、springmvc注解</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.@Controller 写在类上，标记为控制器类</span><br><span class="line">2.@RequestMapping 用来处理请求地址映射的注解</span><br><span class="line">3.@ResponseBody 表示该方法的返回结果直接写入HTTP response body中。一般在异步获取数据时使用</span><br><span class="line">6.@RequestParam 用于将请求参数区数据映射到功能处理方法的参数上 还可以设置默认值</span><br><span class="line">@RequestBody 前端json对象转类对象</span><br><span class="line">@Value从配置文件取值</span><br><span class="line">@PathVaribale注解 用于绑定url中的占位符</span><br><span class="line">4.@Autowired  做bean的在注入时使用</span><br><span class="line">5.@Resource   做bean的在注入时使用</span><br></pre></td></tr></table></figure>

<h2 id="controller和RestController的区别"><a href="#controller和RestController的区别" class="headerlink" title="controller和RestController的区别"></a>controller和RestController的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restController等于controller+responseBody</span><br></pre></td></tr></table></figure>

<h1 id="113、springmvc怎么做文件上传"><a href="#113、springmvc怎么做文件上传" class="headerlink" title="113、springmvc怎么做文件上传"></a>113、springmvc怎么做文件上传</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 input type=&quot;file&quot;</span><br><span class="line">2 method = &quot;post&quot;</span><br><span class="line">3 enctype = &quot;multipart/form-data&quot;</span><br><span class="line"></span><br><span class="line">后台</span><br><span class="line">声明MultipartFile参数接收上传的文件，MultipartFile是接口需要先在配置文件中先声明实现类</span><br><span class="line">1 准备uuid当做新的文件名</span><br><span class="line">2 取出上传文件名的后缀 ext</span><br><span class="line">3 准备上传路径 如果路径不存在 创建出来 </span><br><span class="line">4 文件上传  pic.transferTo(new File(path,uuid+&quot;.&quot;+ext));</span><br><span class="line">5 将新的文件名存入对象  插入数据库</span><br></pre></td></tr></table></figure>

<h1 id="oss实现文件上传流程介绍"><a href="#oss实现文件上传流程介绍" class="headerlink" title="oss实现文件上传流程介绍"></a>oss实现文件上传流程介绍</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">前端只传后端签名</span><br><span class="line">1、web前端请求应用服务器，获取上传所需参数（如oss的accessKeyId、policy、callback等参数）</span><br><span class="line">2、应用服务器返回相关参数</span><br><span class="line">3、web前端直接向oss服务器发起上传文件请求</span><br><span class="line">4、等上传完成后oss服务会回调应用服务器的回调接口</span><br><span class="line">5、应用服务器返回响应给oss服务</span><br><span class="line">6、oss服务将应用服务器回调接口的内容返回给web前端</span><br></pre></td></tr></table></figure>



<h1 id="114、你对springboot的理解"><a href="#114、你对springboot的理解" class="headerlink" title="114、你对springboot的理解"></a>114、你对springboot的理解</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">springboot 是一个快速开发的框架。其采用注解的配置方式，简化了XML配置.并且内置web服务器(tomcat) , 还能够通过自动装配快速整合其他框架，降低了框架整合复杂度,真正开箱即用。</span><br><span class="line"></span><br><span class="line">优点:</span><br><span class="line">a. 是一个快速开发的框架。其采用注解的配置方式，简化了XML配置.</span><br><span class="line">b.内置web服务器(tomcat)，无需部署war文件    它是java项目   打成jar 包   java -jar  XXX.jar</span><br><span class="line">c. 简化了maven配置,其内部封装大部分的主流框架依赖 自动装配spring</span><br></pre></td></tr></table></figure>

<h1 id="115、什么是restful"><a href="#115、什么是restful" class="headerlink" title="115、什么是restful"></a>115、什么是restful</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</span><br><span class="line"></span><br><span class="line">资源：互联网所有的事物都可以被抽象为资源</span><br><span class="line">资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</span><br><span class="line">      分别对应 添加、 删除、修改、查询。</span><br></pre></td></tr></table></figure>

<h1 id="116、redis的数据类型有哪些"><a href="#116、redis的数据类型有哪些" class="headerlink" title="116、redis的数据类型有哪些"></a>116、redis的数据类型有哪些</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) 字符串类型 string</span><br><span class="line">2) 哈希类型 hash</span><br><span class="line">3) 列表类型 list</span><br><span class="line">4) 集合类型 set</span><br><span class="line">5) 有序集合类型 sortedset（zset）</span><br></pre></td></tr></table></figure>

<h1 id="117、redis的持久化机制"><a href="#117、redis的持久化机制" class="headerlink" title="117、redis的持久化机制"></a>117、redis的持久化机制</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、RDB：默认方式，不需要进行配置，默认就使用这种机制</span><br><span class="line">	* 在一定的间隔时间中，检测key的变化情况，然后持久化数据</span><br><span class="line">2、AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据</span><br></pre></td></tr></table></figure>

<h1 id="redis的应用场景"><a href="#redis的应用场景" class="headerlink" title="redis的应用场景"></a>redis的应用场景</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">•   缓存（数据查询、短连接、新闻内容、商品内容等等）</span><br><span class="line">•   聊天室的在线好友列表</span><br><span class="line">•   任务队列。（秒杀、抢购、12306等等）</span><br><span class="line">•   应用排行榜</span><br><span class="line">•   网站访问统计</span><br><span class="line">•   数据过期处理（可以精确到毫秒</span><br><span class="line">•   分布式集群架构中的session分离</span><br></pre></td></tr></table></figure>



<h1 id="118、-NOSQL和关系型数据库比较"><a href="#118、-NOSQL和关系型数据库比较" class="headerlink" title="118、 NOSQL和关系型数据库比较"></a>118、 NOSQL和关系型数据库比较</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，</span><br><span class="line">让NoSQL数据库对关系型数据库的不足进行弥补。</span><br><span class="line">一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</span><br></pre></td></tr></table></figure>

<h1 id="119、ajax技术体系的组成部分有哪些"><a href="#119、ajax技术体系的组成部分有哪些" class="headerlink" title="119、ajax技术体系的组成部分有哪些"></a>119、ajax技术体系的组成部分有哪些</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- html  做题时不选</span><br><span class="line">css</span><br><span class="line">dom</span><br><span class="line">xml</span><br><span class="line">xmlHttpRequest 核心对象 根据它来发送ajax请求（js的内置对象）</span><br><span class="line">javaScript</span><br></pre></td></tr></table></figure>

<h1 id="120、项目衍进流程："><a href="#120、项目衍进流程：" class="headerlink" title="120、项目衍进流程："></a>120、项目衍进流程：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、单体架构 所有的功能集中一个项目</span><br><span class="line">2、分布式架构 按照功能拆分成多个子系统，每个子系统还是包含完整的三层架构</span><br><span class="line">3、soa面向服务的架构，把工程拆分成服务层和表现层2层</span><br><span class="line">  表现层只负责接收用户请求，然后调用服务层查询数据库处理请求</span><br><span class="line">4、微服务  </span><br></pre></td></tr></table></figure>

<h1 id="自动生成接口文档"><a href="#自动生成接口文档" class="headerlink" title="自动生成接口文档"></a>自动生成接口文档</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">项目继承swagger插件</span><br><span class="line">swagger文档</span><br><span class="line">回去自学</span><br></pre></td></tr></table></figure>

<h1 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">正向代理有什么用为什么要这么做：</span><br><span class="line">作用：正向代理隐藏了用户，用户的请求被代理服务器接收代替，到了服务器，服务器并不知道用户是谁。</span><br><span class="line">用途：当你用浏览器访问国外的网站时，被block(拒绝)时，你可以在国外搭建一个代理服务器，这样就可以正常访问了（只是举一个列子） </span><br><span class="line">反向代理有什么用为什么要这么做：</span><br><span class="line">作用：用户请求过多，服务器会有一个处理的极限。所以使用反向代理服务器接受请求，再用均衡负载将请求分布给多个真实的服务器。既能提高效率还有一定的安全性。</span><br><span class="line">用途：如果不采用代理，用户的IP、端口号直接暴露在Internet（尽管地址转换NAT），外部主机依然可以根据IP、端口号来开采主机安全漏洞，所以在企业网，一般都是采用代理服务器访问互联网。</span><br><span class="line">正向代理与反向代理最简单的区别：</span><br><span class="line">正向代理隐藏的是用户，反向代理隐藏的是服务器</span><br></pre></td></tr></table></figure>

<h1 id="gc垃圾回收"><a href="#gc垃圾回收" class="headerlink" title="gc垃圾回收"></a>gc垃圾回收</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1 什么是GC</span><br><span class="line">程序运行时，内存空间是有限的，如何及时的把不再使用的对象清除,将内存释放出来，这就是GC要做的事</span><br><span class="line"></span><br><span class="line">2 需要GC的内存区域</span><br><span class="line">jvm有5块内存</span><br><span class="line">其中程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理</span><br><span class="line">因此，我们的内存垃圾回收主要集中于 java 堆和方法区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3 GC的对象</span><br><span class="line">需要进行回收的对象就是已经没有存活的对象，比如这个对象在栈中没有任何变量引用</span><br><span class="line"></span><br><span class="line">4 gc的触发时机</span><br><span class="line">(1)程序调用System.gc()时可以触发</span><br><span class="line"></span><br><span class="line">(2)系统自身来决定GC触发的时机（根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程）</span><br><span class="line"></span><br><span class="line">GC的核心算法</span><br><span class="line">	1、标记清除法/标记压缩法</span><br><span class="line">	2、复制收集算法</span><br><span class="line">	3、引用计数法</span><br></pre></td></tr></table></figure>

<h1 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一次操作更新或修改多张表，一般为了保证数据一致，需要增加事务处理</span><br><span class="line">在项目中创建一个TransactionManagementConfig类，开启基于注解的事务管理对@Transactional</span><br><span class="line">总结：在@Transactional注解中，如果不配置rollbackFor属性，那么事务只会在遇到RuntimeException的时候才会回滚，如果加上rollbackFor=Exception.class，可以让事务在遇到非运行时异常时也回滚</span><br><span class="line">小节：自定义异常一般可以选择继承RuntimeExceptioin</span><br><span class="line">如果发生检查异常Exception时，想让事务正常回滚，可以进行配置：@Transactional(rollbackFor = Exception.class)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.sc.springcloud.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">@Configuration</span><br><span class="line">public class TransactionManagementConfig &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Springmvc和spring的区别"><a href="#Springmvc和spring的区别" class="headerlink" title="Springmvc和spring的区别"></a>Springmvc和spring的区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Springmvc是控制层，用来接收前台传值，调用service层和持久层，返回数据再通过springmvc层把数据返回到前台。</span><br><span class="line">Spring是框架的粘合剂，有ioc控制反转依赖注入和aop面向切面编程</span><br></pre></td></tr></table></figure>





<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h1 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h1><h3 id="shiro-jwt-redis-无状态token登录"><a href="#shiro-jwt-redis-无状态token登录" class="headerlink" title="shiro+jwt+redis - 无状态token登录"></a><em>shiro+jwt+redis</em> - 无状态<em>token</em>登录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">权限管理框架</span><br><span class="line">可以帮助我们完成：</span><br><span class="line">	身份认证/登录：验证用户是不是拥有相应的身份；</span><br><span class="line">	授权(权限验证)：验证某个已认证的用户是否拥有某个权限；即判断用</span><br><span class="line">户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用</span><br><span class="line">户对某个资源是否具有某个权限；</span><br><span class="line">	加密：保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</span><br><span class="line">	会话管理：用户登录后就是一次会话，在没有退出之前，它的所有信</span><br><span class="line">息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的</span><br><span class="line">	Web 集成</span><br><span class="line">	缓存：比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</span><br><span class="line">	Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了</span><br><span class="line">做到快速开发，降低系统成本</span><br><span class="line">shiro相比于spring security，spring security依赖spring运行，而shiro相对独立，最主要的是因为shiro使用简单、灵活，所以现在越来越多的用户选择shiro。</span><br></pre></td></tr></table></figure>



<h1 id="rabbitMQ（消息队列-kafka）"><a href="#rabbitMQ（消息队列-kafka）" class="headerlink" title="rabbitMQ（消息队列 kafka）"></a>rabbitMQ（消息队列 kafka）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">应用场景：</span><br><span class="line">1、任务异步处理。</span><br><span class="line">将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</span><br><span class="line">比如注册完成之后，可以通过消息队列，异步的发送短信以及邮件给注册成功的用户提示已注册成功</span><br><span class="line">2、应用程序解耦合</span><br><span class="line">MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</span><br><span class="line"></span><br><span class="line">为什么使用RabbitMQ呢？</span><br><span class="line">1、使用简单，功能强大。</span><br><span class="line">2、基于AMQP协议。</span><br><span class="line">3、社区活跃，文档完善。</span><br><span class="line">4、高并发性能好，这主要得益于Erlang语言。 5、Spring Boot默认已集成RabbitMQ</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">、发送端操作流程</span><br><span class="line">1）创建连接</span><br><span class="line">2）创建通道</span><br><span class="line">3）声明队列</span><br><span class="line">4）发送消息</span><br><span class="line">2、接收端</span><br><span class="line">1）创建连接</span><br><span class="line">2）创建通道</span><br><span class="line">3）声明队列</span><br><span class="line">4）监听队列</span><br><span class="line">5）接收消息</span><br><span class="line">6）ack回复</span><br></pre></td></tr></table></figure>

<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RabbitMQ有以下几种工作模式 ：</span><br><span class="line">1、Work queues 工作队列</span><br><span class="line">2、Publish/Subscrib 发布订阅</span><br><span class="line">3、Routing 路由</span><br><span class="line">4、Topics 通配符</span><br><span class="line">5、Header Header转发器</span><br><span class="line">6、RPC 远程过程调用</span><br></pre></td></tr></table></figure>

<h1 id="前后端分离项目中的日期格式化"><a href="#前后端分离项目中的日期格式化" class="headerlink" title="前后端分离项目中的日期格式化"></a>前后端分离项目中的日期格式化</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据库查询的时间返回给前端：</span><br><span class="line">	1、给字段添加注解    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone=&quot;GMT+8&quot;)</span><br><span class="line">	2、application.properties中进行全局配置</span><br><span class="line">		spring.jackson.date-format=yyyy-MM-dd</span><br><span class="line">前端数据传到后台数据对象的属性上 加：@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="netflix-网飞"><a href="#netflix-网飞" class="headerlink" title="netflix(网飞)"></a>netflix(网飞)</h1><h1 id="eureka服务注册与发现"><a href="#eureka服务注册与发现" class="headerlink" title="eureka服务注册与发现"></a>eureka服务注册与发现</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eureka做服务注册与服务发现功能的    生活举例   相当于卖房过程中的房产中介</span><br><span class="line">卖房的人将房产信息注册到中介，买房的人通过中介发现卖房人信息，最终根据卖房人信息找到卖房人继续完成后续操作</span><br></pre></td></tr></table></figure>

<h1 id="ribbon负载均衡服务"><a href="#ribbon负载均衡服务" class="headerlink" title="ribbon负载均衡服务"></a>ribbon负载均衡服务</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端负载均衡 基于eureka的服务发现根据微服务名找到服务提供者的list集合，在通过IRule的负载均衡规则在list集合中选择一台服务提供者，根据ip和端口号进行远程调用</span><br></pre></td></tr></table></figure>

<h1 id="OpenFeign服务接口调用"><a href="#OpenFeign服务接口调用" class="headerlink" title="OpenFeign服务接口调用"></a>OpenFeign服务接口调用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">远程服务接口调用，Feign是一个声明式WebService客户端，使用Feign能让编写web Service客户端更加简单，它的使用方法就是定义已给接口，然后再上面添加注解，OpenFeign是springcloud在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等，OpenFeign的@FeignClient可以解析SpringMVC的@RequestMappinig注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务</span><br></pre></td></tr></table></figure>

<h1 id="Hystrix断路器"><a href="#Hystrix断路器" class="headerlink" title="Hystrix断路器"></a>Hystrix断路器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用于服务降级和服务熔断</span><br><span class="line">在分布式应用中存在服务雪崩效应，服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</span><br><span class="line">例如：A是服务提供者，B依赖于A，而C和D又依赖于B,如果A出现故障会导致B出现问题，并且将问题扩大到C和D，雪崩效应就形成了</span><br><span class="line">解决方法</span><br><span class="line">1 服务降级</span><br><span class="line">如果A服务器出现故障，可以返回一个备用信息，做服务降级，这样B不用一直等待A的结果，可以正常做其他事情</span><br><span class="line">2 服务熔断</span><br><span class="line">当在一定的时间内，发出的请求次数达到的熔断要求的请求总数，并且错误百分比也到达了设定值，将断路器打开，这时所有的请求直接拒绝，返回降级信息。当一段时间过后，断路器进入半开状态，将一条请求放行，如果响应正常，断路器关闭，否则断路器重新进入打开状态。</span><br></pre></td></tr></table></figure>

<h1 id="Geteway网关"><a href="#Geteway网关" class="headerlink" title="Geteway网关"></a>Geteway网关</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是一个网关  </span><br><span class="line">在微服务架构中，后端服务不会直接开放给调用端，而是通过一个API网关比如gateway根据请求的url，路由到相应的服务工程。当添加API网关后，由API网关直接与调用方通信进行权限控制，后将请求均衡的分发给后台服务端。</span><br></pre></td></tr></table></figure>

<h1 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h1><h1 id="mybatis-plus"><a href="#mybatis-plus" class="headerlink" title="mybatis-plus"></a>mybatis-plus</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">version（乐观锁）、deleted（逻辑删除）、gmt_create、gmt_modified</span><br><span class="line">lombok注解</span><br><span class="line">@Date</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">实体类注解：</span><br><span class="line">@TableI(type=Idtype.)   标识为主键  一般设置ASSIGN_ID 雪花算法</span><br><span class="line">@TableField(fill = FieldFill.INSERT)   表示表的字段 数据插入时操作</span><br><span class="line">@TableField(fill = FieldFill.INSERT_UPDATE)   表示表的字段 数据更新时操作</span><br><span class="line">@Version    代表改字段是乐观锁version注解 </span><br><span class="line">@TableField(exist = false) ，表示该字段在数据库中不存在 ，所以不会插入数据库中</span><br><span class="line">@TableLogic   逻辑删除注解</span><br></pre></td></tr></table></figure>



<h1 id="nacos（服务注册与发现-配置中心）"><a href="#nacos（服务注册与发现-配置中心）" class="headerlink" title="nacos（服务注册与发现 配置中心）"></a>nacos（服务注册与发现 配置中心）</h1><h1 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h1><h1 id="ssm"><a href="#ssm" class="headerlink" title="ssm"></a>ssm</h1><h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">文件目录类：</span><br><span class="line">    pwd   显示当前所在位置</span><br><span class="line">    ls 查看该目录下的所有的目录和文件</span><br><span class="line">    cd 切换目录</span><br><span class="line">    mkdir  增加目录操作   加-p创建多级目录</span><br><span class="line">	touch 指令创建空文件</span><br><span class="line">	cp   复制文件</span><br><span class="line">	rm  删除目录或者文件</span><br><span class="line">	mv  修改目录或文件名或者是移动目录或者文件</span><br><span class="line">	cat/more/less/tail  查看文件</span><br><span class="line">		cat只能显示最后一屏内容</span><br><span class="line">		more可以显示百分比 回车向下一行 空格向下一页</span><br><span class="line">		less使用键盘上的PgUp和PgDn向上	和向下翻页</span><br><span class="line">		tail -10 查看文件的后10行</span><br><span class="line">&gt; 输出重定向 : 会将原来的文件的内容覆盖   ls -l &gt;文件</span><br><span class="line">&gt;&gt; 追加： 不会覆盖原来文件的内容，而是追加到文件的尾部。	ls -l &gt;&gt;文件	</span><br><span class="line">vim 正常模式  插入模式/编辑模式     命令行模式</span><br><span class="line">	:wq 保存文件退出</span><br><span class="line">	:q! 不保存文件退出</span><br><span class="line">	yy拷贝    5yy当前行向下5行拷贝   p粘贴</span><br><span class="line">	dd删除     5dd删除当前行向下5行</span><br><span class="line">	设置行号 取消行号:set nu  :set nonu </span><br><span class="line">    u退回上一步</span><br><span class="line">搜索查找类</span><br><span class="line">	find  查找文件或目录   find /root -name &quot;*.txt&quot;</span><br><span class="line">压缩解压类</span><br><span class="line">	tar -zcvf 打包压缩后的文件名 要打包压缩的文件</span><br><span class="line">		z：调用gzip压缩命令进行压缩</span><br><span class="line">        c：打包文件</span><br><span class="line">        v：显示运行过程</span><br><span class="line">        f：指定文件名</span><br><span class="line">    tar [-xvf] 压缩文件</span><br><span class="line">    	x：</span><br><span class="line">rpm -qa  查找已安装所有rpm软件包</span><br><span class="line">rpm -qa | grep xx  查找xx是否已安装  </span><br><span class="line">yum list | grep xx   软件列表</span><br><span class="line">yum install xx  下载安装</span><br><span class="line">shutdown -h now立即关机</span><br><span class="line">reboot  重启</span><br><span class="line">useradd  用户名  新建用户</span><br><span class="line">passwd 用户名     指定密码</span><br><span class="line">userdel 用户名    删除用户</span><br><span class="line">useradd -g 用户组 用户名   增加用户时直接加上组</span><br></pre></td></tr></table></figure>

<h1 id="Linux中Vi和Vim区别是什么"><a href="#Linux中Vi和Vim区别是什么" class="headerlink" title="Linux中Vi和Vim区别是什么?"></a>Linux中Vi和Vim区别是什么?</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、多级撤销：在VI里，按u只可以撤销上次命令，但是在vim里面可以无限制撤销;</span><br><span class="line">2、易用性：vi只能运行于Unix中，而vim不仅可以运用于Unix，还可以运行于Linux、Windows、mac等多个操作平台;</span><br><span class="line">3、语法加亮：vim可以用不同的颜色来加亮你的代码;</span><br><span class="line">4、可视化操作：vim不仅可以在终端运行，还可以运行于x Windows、Mac os、Windows。</span><br><span class="line">5、对vi完全兼容：某种情况下，你可以将vim当做vi来使用。</span><br><span class="line">vi和vim同属于Linux中的编辑器，但是vim比较高级，可以当做vi的升级版本</span><br></pre></td></tr></table></figure>

<h1 id="springcloud"><a href="#springcloud" class="headerlink" title="springcloud"></a>springcloud</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka、ribbon、openFeign、Hystrix、geteway</span><br></pre></td></tr></table></figure>



<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="亮点-展现自己的亮点"><a href="#亮点-展现自己的亮点" class="headerlink" title="亮点  展现自己的亮点"></a>亮点  展现自己的亮点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自学一项新技术  并且把技术应用到项目里面   自学能力很好</span><br><span class="line">模块需要的前端页面和后台逻辑都是一个人完成  独立开发一个模块  开发能力强</span><br></pre></td></tr></table></figure>

<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在开发之前，会做需求分析，将表设计好，在做开发</span><br></pre></td></tr></table></figure>

<h2 id="底层和应用开发关系-了解底层对开发什么好处"><a href="#底层和应用开发关系-了解底层对开发什么好处" class="headerlink" title="底层和应用开发关系  了解底层对开发什么好处"></a>底层和应用开发关系  了解底层对开发什么好处</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashmap底层和开发应用的关系</span><br><span class="line">答: 底层和开发肯定是有关系，比如知道了Hashmap底层以后，就知道了为了确保key的唯一性，调用了hashcode()和equals()2个方法。所以在开发中如果将自定义的对象作为key时，我需要在类中重写hashcode和equals()2个方法。</span><br><span class="line">还有HashMap是线程非安全的，如果考虑线程安全问题，可以使用ConcurrentHashMap.</span><br><span class="line"></span><br><span class="line">然后我们开发项目都是使用了框架，如果熟悉底层原理，以后切换其他框架也可以很快上手。或者在开发过程中遇到问题，可以很快的定位到错误，解决隐患。</span><br></pre></td></tr></table></figure>

<h1 id="前后端分离的项目，如何解决跨域问题的？"><a href="#前后端分离的项目，如何解决跨域问题的？" class="headerlink" title="前后端分离的项目，如何解决跨域问题的？"></a>前后端分离的项目，如何解决跨域问题的？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">https://note.youdao.com/ynoteshare/index.html?id=87a205bf932427d5934cb969896a697e&amp;type=note&amp;_time=1644915146565</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@WebFilter(urlPatterns = &quot;/&quot;, filterName = &quot;myOriginFilter&quot;)</span><br><span class="line">@Order(1)//指定过滤器的执行顺序,值越大越靠后执行</span><br><span class="line">public class OriginFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletResponse httpServletResponse = (HttpServletResponse) response;</span><br><span class="line">        request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        // 处理跨域</span><br><span class="line">        //允许跨域访问的域，可以是一个域的列表，也可以是通配符”*”；</span><br><span class="line">        httpServletResponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">        //允许脚本访问的返回头，请求成功后，脚本可以在XMLHttpRequest中访问这些头的信息</span><br><span class="line">        httpServletResponse.setHeader(&quot;Access-Control-Expose-Headers&quot;, &quot;*&quot;);</span><br><span class="line">        //允许自定义的头部，以逗号隔开，大小写不敏感；</span><br><span class="line">        httpServletResponse.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">        //允许使用的请求方法，以逗号隔开；</span><br><span class="line">        httpServletResponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</span><br><span class="line">        //缓存此次请求的秒数。在这个时间范围内，所有同类型的请求都将不再发送预检请求而是直接使用此次返回的头作为判断依据，非常有用，大幅优化请求次数；</span><br><span class="line">        httpServletResponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;10000&quot;);</span><br><span class="line">        //自定义的头部，所有用setRequestHeader方法设置的头部都将会以逗号隔开的形式包含在这个头中，要与响应头中的Access-Control-Allow-Headers相匹配才能进行跨域访问</span><br><span class="line">        request.setAttribute(&quot;Access-Control-Request-Headers&quot;, &quot;*&quot;);</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spring跨域注解 @CrossOrigin。</span><br><span class="line">对B项目HelloController做如下修改，添加@CrossOrigin注解。跨域问题解决</span><br><span class="line">@CrossOrigin(origins = &quot;*&quot;,maxAge = 3600)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">  @ResponseBody</span><br><span class="line">  @GetMapping(&quot;/hello&quot;)</span><br><span class="line">  public Map&lt;String,Object&gt; hello(String name)&#123;</span><br><span class="line">      System.out.println(&quot;接收到请求，name=&quot;+name);</span><br><span class="line">      Map&lt;String,Object&gt; result=new HashMap&lt;&gt;();</span><br><span class="line">      result.put(&quot;code&quot;,&quot;200&quot;);</span><br><span class="line">      result.put(&quot;msg&quot;,&quot;hello &quot;+name);</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="看你项目负责的功能不多，怎么需要这么长时间"><a href="#看你项目负责的功能不多，怎么需要这么长时间" class="headerlink" title="看你项目负责的功能不多，怎么需要这么长时间"></a>看你项目负责的功能不多，怎么需要这么长时间</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 不是说三四个月都在写代码，是从需求分析，项目开发，项目测试整个时间是这么长，其中项目测试其实会花费挺长时间。</span><br><span class="line">1、立项</span><br><span class="line">2、项目需求评审</span><br><span class="line">3、项目架构搭建</span><br><span class="line">4、项目需求分配(熟悉框架)</span><br><span class="line">5、开发时间预估</span><br><span class="line">6、代码开发</span><br><span class="line">7、项目部署</span><br><span class="line">8、提交测试</span><br><span class="line">9、bug回归</span><br><span class="line">10、一轮需求 二轮需求 三轮需求</span><br></pre></td></tr></table></figure>

<h1 id="为什么离职"><a href="#为什么离职" class="headerlink" title="为什么离职"></a>为什么离职</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之前是因为自己刚踏入it行业，正好有个玩得好的朋友在福州发展，认为去那边发展的话正好能有个照应，在福州发展了1年了，想着离家近一点也更好点，离宜春近的地方，也就只有南昌，所以离职来南昌这边了</span><br></pre></td></tr></table></figure>

<h1 id="介绍下你的项目"><a href="#介绍下你的项目" class="headerlink" title="介绍下你的项目"></a>介绍下你的项目</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">人力资源管理系统：</span><br><span class="line">我主要负责了基本信息，考勤管理，工资管理，</span><br><span class="line">基本信息： 员工信息表，部门表，（部门职位中间表），职位表  主要包括开通账户并记录员工的信息，以及入职后的工作岗位</span><br><span class="line">考勤管理：考勤表，排班表（分配员工的工作时间，也可以根据部门统一分配）</span><br><span class="line"></span><br><span class="line">汽车服务管理</span><br><span class="line">主要的模块，销售模块，车辆模块，客户模块，维修模块等</span><br><span class="line">我主要参与了销售模块，车辆模块</span><br><span class="line"></span><br><span class="line">物业管理系统</span><br><span class="line">我主要只负责了3个模块  楼栋管理、业主管理以及采购管理</span><br><span class="line">就以楼栋管理为例：楼栋管理分为楼栋信息管理，单元信息管理，房屋管理，商铺管理</span><br><span class="line">楼栋信息：id  名称 分区(A/B/C/D) 编号 创建员工id  创建时间 最后一次修改时间 </span><br><span class="line">对楼栋管理进行curd，且很多信息都做了poi的导入导出操作</span><br><span class="line">房屋管理的话，查询的时候可以直接指定哪一栋进行搜索房屋信息，以及可以根据房屋状态  已入住、</span><br><span class="line">楼栋管理主要是对小区内的楼栋信息，单元信息，房屋信息以及商铺管理进行管理与查询，以及利用poi对信息进行批量导入导出，</span><br><span class="line">业主管理主要有业主信息，对业主进行房屋绑定，房屋解绑，以及点详情可以查看业主绑定的房屋信息和车位信息以及可以去查看响应的的物业费</span><br><span class="line">业主的账户信息管理，主要是查看业主账户中还有多少余额，对账户余额进行充值，以及账户明细对账户充值记录的管理</span><br><span class="line">房屋与业主的绑定情况</span><br><span class="line">采购管理大致分为库存信息，采购物品，物品出库</span><br><span class="line">采购管理：仓库信息，物品信息，物品类型，物品供应商，物品规格，采购申请，出入库明细，调拨记录，调拨明细主要是为了poi的导出，物品领用</span><br><span class="line">库存信息主要有  仓库信息，物品信息（仓库的物品库存），物品的类型，物品的规格（例如物品什么颜色，物品的长宽，物品是多少瓦的）</span><br><span class="line">采购物品主要有  采购流程管理，采购申请，采购代办，采购已办</span><br><span class="line">物品出库，领用流程管理，领用申请，领用代办，领用已办</span><br></pre></td></tr></table></figure>

<h2 id="2到3年的职业规划-必问"><a href="#2到3年的职业规划-必问" class="headerlink" title="2到3年的职业规划  必问********"></a>2到3年的职业规划  必问********</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、前期在开发项目的同时尽快熟悉业务</span><br><span class="line">2、中期不断提升自己的开发能力，最终可以负责核心模块</span><br><span class="line">3、后期可以参与项目的管理，把控一个项目的整体开发</span><br></pre></td></tr></table></figure>

<h2 id="对公司想了解的问题"><a href="#对公司想了解的问题" class="headerlink" title="对公司想了解的问题"></a>对公司想了解的问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">贵公司使用什么技术?</span><br><span class="line">开发团队的规模</span><br><span class="line">有什么福利</span><br></pre></td></tr></table></figure>

<h1 id="你的项目几个人开发的，开发了多长时间"><a href="#你的项目几个人开发的，开发了多长时间" class="headerlink" title="你的项目几个人开发的，开发了多长时间"></a>你的项目几个人开发的，开发了多长时间</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开发团队：前端1人，后端三人以及项目经理</span><br><span class="line">用的什么数据库？部署在哪里？地址有吗？多少人在用？</span><br><span class="line">关于部署在哪？地址是多少？多少人在用这块的问题，如果项目不是给自己开发的，都可以说不清楚，我做完开发之后，部署这块是公司实施去部署的，后面我没有管这些。</span><br></pre></td></tr></table></figure>

<h1 id="你以前工资多少？有交五险一金吗"><a href="#你以前工资多少？有交五险一金吗" class="headerlink" title="你以前工资多少？有交五险一金吗"></a>你以前工资多少？有交五险一金吗</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">面试的效果可以    前期刚去是6k   后期涨到7.5k </span><br><span class="line">没有交一金，五险的话是折现给我发的</span><br></pre></td></tr></table></figure>

<h1 id="你最快什么时候能够入职？"><a href="#你最快什么时候能够入职？" class="headerlink" title="你最快什么时候能够入职？"></a>你最快什么时候能够入职？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以找理由稍微延后几天，最好不要超过三天。</span><br><span class="line">可以说需要找房子，晚个三天入职等。。。</span><br></pre></td></tr></table></figure>

<h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h3 id="vue组件的属性名介绍："><a href="#vue组件的属性名介绍：" class="headerlink" title="vue组件的属性名介绍："></a>vue组件的属性名介绍：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1）数据</span><br><span class="line">data:Vue 实例的数据对象</span><br><span class="line">components：Vue实例配置局部注册组件</span><br><span class="line">（2）类方法</span><br><span class="line">computed:计算属性</span><br><span class="line">watch：侦听属性</span><br><span class="line">filters：过滤器</span><br><span class="line">methods:Vue实例方法</span><br><span class="line">render：渲染函数，创建虚拟DOM</span><br><span class="line">（3）生命周期</span><br><span class="line">created：在实例创建完成后被立即调用，完成初始化操作</span><br><span class="line">mounted：el挂载到Vue实例上了，开始业务逻辑操作</span><br><span class="line">beforeDestroy：实例销毁之前调用</span><br><span class="line">2、Vue组件</span><br><span class="line">props:用于接收来自父组件的数据</span><br><span class="line">template：组件模板</span><br></pre></td></tr></table></figure>

<h3 id="使用箭头函数和普通函数的区别"><a href="#使用箭头函数和普通函数的区别" class="headerlink" title="使用箭头函数和普通函数的区别"></a>使用箭头函数和普通函数的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</span><br><span class="line">2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，</span><br><span class="line">这样this的指向才是vm 或 组件实例对象。</span><br></pre></td></tr></table></figure>

<h3 id="父组件调用子组件"><a href="#父组件调用子组件" class="headerlink" title="父组件调用子组件"></a>父组件调用子组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先父组件给子节点打标识，设置子节点的ref属性设置标识名   &lt;pagination ref=&quot;pagination&quot;&gt;&lt;/pagination&gt;</span><br><span class="line">父组件中通过this.$refs.标识名.方法()</span><br></pre></td></tr></table></figure>

<h3 id="父子组件相互调动"><a href="#父子组件相互调动" class="headerlink" title="父子组件相互调动"></a>父子组件相互调动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent /children：访问父 / 子实例</span><br></pre></td></tr></table></figure>



<h3 id="子组件调用父组件"><a href="#子组件调用父组件" class="headerlink" title="子组件调用父组件"></a>子组件调用父组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先父组件给子节点添加v-bind:子组件声明的接收名=&quot;方法名&quot;  </span><br><span class="line">父组件中写&lt;pagination v-bind:list=&quot;list&quot;&gt;&lt;/pagination&gt;</span><br><span class="line">子组件中写 props: &#123;list: &#123;type: Function,default: null &#125; &#125;</span><br><span class="line">子组件通过this.list直接可以调用父组件的list方法了</span><br></pre></td></tr></table></figure>

<h3 id="如何实现不是父子关系的组件之间的相互调用"><a href="#如何实现不是父子关系的组件之间的相互调用" class="headerlink" title="如何实现不是父子关系的组件之间的相互调用"></a>如何实现不是父子关系的组件之间的相互调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、全局事件总线   先在vue的原型对象中添加一个$bus属性，这样所有组件对象都能看见$bus这个属性对象</span><br><span class="line">  包含事件处理相关方法的对象(只有一个) 所有的组件都可以得到</span><br><span class="line">  Vue 原型对象上包含事件处理的方法：</span><br><span class="line">  	1) $on(eventName, listener): 绑定自定义事件监听</span><br><span class="line">  	2) $emit(eventName, data): 分发自定义事件</span><br><span class="line">  	3) $off(eventName): 解绑自定义事件监听</span><br><span class="line">  	4) $once(eventName, listener): 绑定事件监听, 但只能处理一次</span><br><span class="line">2、消息订阅与发布</span><br><span class="line">	包含以下操作:</span><br><span class="line">        (1) 订阅消息 --对应绑定事件监听 </span><br><span class="line">        (2) 发布消息 --分发事件 </span><br><span class="line">        (3) 取消消息订阅 --解绑事件监听 </span><br><span class="line">	需要引入一个消息订阅与发布的第三方实现库: PubSubJS</span><br><span class="line">3、vuex</span><br><span class="line">	专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应 用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方 式，且适用于任意组件间通信</span><br><span class="line">	使用场景:1. 多个组件依赖于同一状态 2. 来自不同组件的行为需要变更同一状态</span><br></pre></td></tr></table></figure>

<h3 id="vue项目的ajax库-axios"><a href="#vue项目的ajax库-axios" class="headerlink" title="vue项目的ajax库:axios"></a>vue项目的ajax库:axios</h3><h3 id="router"><a href="#router" class="headerlink" title="router"></a>router</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 定义路由组件 2注册路由3 使用路由  实现路由跳转</span><br></pre></td></tr></table></figure>

<h3 id="谈谈你对-Vue-生命周期的理解？"><a href="#谈谈你对-Vue-生命周期的理解？" class="headerlink" title="谈谈你对 Vue 生命周期的理解？"></a>谈谈你对 Vue 生命周期的理解？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">（1）生命周期是什么？</span><br><span class="line">Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</span><br><span class="line">（2）各个生命周期的作用</span><br><span class="line">生命周期 	描述</span><br><span class="line">beforeCreate 	组件实例被创建之初，组件的属性生效之前</span><br><span class="line">created 	组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</span><br><span class="line">beforeMount 	在挂载开始之前被调用：相关的 render 函数首次被调用</span><br><span class="line">mounted 	el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</span><br><span class="line">beforeUpdate 	组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</span><br><span class="line">update 	组件数据更新之后</span><br><span class="line">activited 	keep-alive 专属，组件被激活时调用</span><br><span class="line">deactivated 	keep-alive 专属，组件被销毁时调用</span><br><span class="line">beforeDestory 	组件销毁前调用</span><br><span class="line">destoryed 	组件销毁后调用</span><br></pre></td></tr></table></figure>

<h3 id="直接给一个数组项赋值，Vue-能检测到变化吗？"><a href="#直接给一个数组项赋值，Vue-能检测到变化吗？" class="headerlink" title="直接给一个数组项赋值，Vue 能检测到变化吗？"></a>直接给一个数组项赋值，Vue 能检测到变化吗？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</span><br><span class="line">    当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</span><br><span class="line">    当你修改数组的长度时，例如：vm.items.length = newLength</span><br><span class="line">了解决第一个问题，Vue 提供了以下操作方法：</span><br><span class="line">	 Vue.set</span><br><span class="line">为了解决第二个问题，Vue 提供了以下操作方法</span><br><span class="line">	 Array.prototype.splice</span><br></pre></td></tr></table></figure>

<h3 id="computed-和-watch-的区别和运用的场景？"><a href="#computed-和-watch-的区别和运用的场景？" class="headerlink" title="computed 和 watch 的区别和运用的场景？"></a>computed 和 watch 的区别和运用的场景？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">omputed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</span><br><span class="line">watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</span><br><span class="line">运用场景：</span><br><span class="line">    当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</span><br><span class="line">    当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</span><br></pre></td></tr></table></figure>

<h3 id="v-show-与-v-if-有什么区别？"><a href="#v-show-与-v-if-有什么区别？" class="headerlink" title="v-show 与 v-if 有什么区别？"></a>v-show 与 v-if 有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</span><br><span class="line">v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</span><br><span class="line">所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</span><br></pre></td></tr></table></figure>

<h3 id="说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</span><br><span class="line">优点：</span><br><span class="line">    用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</span><br><span class="line">    基于上面一点，SPA 相对对服务器压力小；</span><br><span class="line">    前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</span><br><span class="line">缺点：</span><br><span class="line">	初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</span><br><span class="line">    前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</span><br><span class="line">    SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</span><br></pre></td></tr></table></figure>



<h3 id="什么是-MVVM？"><a href="#什么是-MVVM？" class="headerlink" title="什么是 MVVM？"></a>什么是 MVVM？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Model–View–ViewModel （MVVM） 是一个软件架构设计模式，是一种简化用户界面的事件驱动编程方式。</span><br><span class="line">MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。</span><br></pre></td></tr></table></figure>

<h3 id="Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>Vue 的父组件和子组件生命周期钩子函数执行顺序？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</span><br><span class="line">加载渲染过程</span><br><span class="line">父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</span><br><span class="line">子组件更新过程</span><br><span class="line">父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</span><br><span class="line">父组件更新过程</span><br><span class="line">父 beforeUpdate -&gt; 父 updated</span><br><span class="line">销毁过程</span><br><span class="line">父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</span><br></pre></td></tr></table></figure>

<h3 id="谈谈你对-keep-alive-的了解？"><a href="#谈谈你对-keep-alive-的了解？" class="headerlink" title="谈谈你对 keep-alive 的了解？"></a>谈谈你对 keep-alive 的了解？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</span><br><span class="line">    一般结合路由和动态组件一起使用，用于缓存组件；</span><br><span class="line">    提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</span><br><span class="line">    对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</span><br></pre></td></tr></table></figure>

<h3 id="组件中-data-为什么是一个函数？"><a href="#组件中-data-为什么是一个函数？" class="headerlink" title="组件中 data 为什么是一个函数？"></a>组件中 data 为什么是一个函数？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</span><br></pre></td></tr></table></figure>

<h3 id="v-model-的原理？"><a href="#v-model-的原理？" class="headerlink" title="v-model 的原理？"></a>v-model 的原理？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</span><br><span class="line">text 和 textarea 元素使用 value 属性和 input 事件；</span><br><span class="line">checkbox 和 radio 使用 checked 属性和 change 事件；</span><br><span class="line">select 字段将 value 作为 prop 并将 change 作为事件	</span><br></pre></td></tr></table></figure>

<h3 id="vue-router路由模式有几种？"><a href="#vue-router路由模式有几种？" class="headerlink" title="vue-router路由模式有几种？"></a>vue-router路由模式有几种？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</span><br><span class="line">history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</span><br><span class="line">abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</span><br></pre></td></tr></table></figure>

<h3 id="Vue-框架怎么实现对象和数组的监听？"><a href="#Vue-框架怎么实现对象和数组的监听？" class="headerlink" title="Vue 框架怎么实现对象和数组的监听？"></a>Vue 框架怎么实现对象和数组的监听？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，</span><br><span class="line">Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</span><br></pre></td></tr></table></figure>

<h3 id="react、vue中的key有什么作用？（key的内部原理）"><a href="#react、vue中的key有什么作用？（key的内部原理）" class="headerlink" title="react、vue中的key有什么作用？（key的内部原理）"></a>react、vue中的key有什么作用？（key的内部原理）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. 虚拟DOM中key的作用：</span><br><span class="line">    key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, </span><br><span class="line">    随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</span><br><span class="line">2.对比规则：</span><br><span class="line">    (1).旧虚拟DOM中找到了与新虚拟DOM相同的key：</span><br><span class="line">    ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！</span><br><span class="line">    ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</span><br><span class="line">    (2).旧虚拟DOM中未找到与新虚拟DOM相同的key</span><br><span class="line">		创建新的真实DOM，随后渲染到到页面。</span><br><span class="line">3. 用index作为key可能会引发的问题：</span><br><span class="line">    1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:</span><br><span class="line">    会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</span><br><span class="line">    2. 如果结构中还包含输入类的DOM：</span><br><span class="line">    会产生错误DOM更新 ==&gt; 界面有问题。</span><br><span class="line">4. 开发中如何选择key?:</span><br><span class="line">    1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</span><br><span class="line">    2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，</span><br><span class="line">      使用index作为key是没有问题的。</span><br></pre></td></tr></table></figure>

<h3 id="Vue修改数组中的某个元素一定要用如下方法："><a href="#Vue修改数组中的某个元素一定要用如下方法：" class="headerlink" title="Vue修改数组中的某个元素一定要用如下方法："></a>Vue修改数组中的某个元素一定要用如下方法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.使用这些API:</span><br><span class="line"> push()、可向数组的末尾添加一个或多个元素，并返回新的长度</span><br><span class="line"> pop()、 用于删除并返回数组的最后一个元素</span><br><span class="line"> shift()、 用于把数组的第一个元素从其中删除，并返回第一个元素的值</span><br><span class="line"> unshift()、可向数组的开头添加一个或更多元素，并返回新的长度</span><br><span class="line"> splice()、 向/从数组中添加/删除项目，然后返回被删除的项目</span><br><span class="line"> sort()、   用于对数组的元素进行排序</span><br><span class="line"> reverse()  用于颠倒数组中元素的顺序</span><br><span class="line">2.Vue.set() 或 vm.$set()</span><br><span class="line">  特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</span><br></pre></td></tr></table></figure>

<h3 id="虚拟-DOM-的优缺点？"><a href="#虚拟-DOM-的优缺点？" class="headerlink" title="虚拟 DOM 的优缺点？"></a>虚拟 DOM 的优缺点？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">	保证性能下限</span><br><span class="line">	无需手动操作 DOM</span><br><span class="line">	跨平台</span><br><span class="line">缺点:无法进行极致优化	</span><br></pre></td></tr></table></figure>

<h3 id="虚拟-DOM-实现原理？"><a href="#虚拟-DOM-实现原理？" class="headerlink" title="虚拟 DOM 实现原理？"></a>虚拟 DOM 实现原理？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">虚拟 DOM 的实现原理主要包括以下 3 部分：</span><br><span class="line">    用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</span><br><span class="line">    diff 算法 — 比较两棵虚拟 DOM 树的差异；</span><br><span class="line">    pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</span><br></pre></td></tr></table></figure>

<h3 id="你有对-Vue-项目进行哪些优化？"><a href="#你有对-Vue-项目进行哪些优化？" class="headerlink" title="你有对 Vue 项目进行哪些优化？"></a>你有对 Vue 项目进行哪些优化？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">（1）代码层面的优化</span><br><span class="line">v-if 和 v-show 区分使用场景</span><br><span class="line">computed 和 watch 区分使用场景</span><br><span class="line">v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</span><br><span class="line">长表性能优化</span><br><span class="line">事件的销毁</span><br><span class="line">图片资源懒加载</span><br><span class="line">路由懒加载</span><br><span class="line">第三方插件的按需引入</span><br><span class="line">优化无限列表性能</span><br><span class="line">服务端渲染 SSR or 预渲染</span><br><span class="line">（2）Webpack 层面的优化</span><br><span class="line">Webpack 对图片进行压缩</span><br><span class="line">减少 ES6 转为 ES5 的冗余代码</span><br><span class="line">提取公共代码</span><br><span class="line">模板预编译</span><br><span class="line">提取组件的 CSS</span><br><span class="line">优化 SourceMap</span><br><span class="line">构建结果输出分析</span><br><span class="line">Vue 项目的编译优化</span><br><span class="line">（3）基础的 Web 技术的优化</span><br><span class="line">浏览器缓存</span><br><span class="line">CDN 的使用</span><br><span class="line">使用 Chrome Performance 查找性能瓶颈</span><br></pre></td></tr></table></figure>



<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h3 id="Ascii码"><a href="#Ascii码" class="headerlink" title="Ascii码"></a>Ascii码</h3><blockquote>
<p>A-Z  65-90		</p>
<p>a-z  97-122		</p>
<p>0-9  48-57</p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="https://t.lizi.moe/fj" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/25/%E9%AA%8C%E8%AF%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E6%B3%A8%E8%A7%A3/" title="验证身份证号注解"><img class="cover" src="https://t.lizi.moe/fj" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">验证身份证号注解</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/23/%E7%AC%94%E8%AE%B0/" title=""><img class="cover" src="https://t.lizi.moe/fj" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/06/1-%E5%88%9D%E8%AF%86Java/" title="1.1_初识Java"><img class="cover" src="https://gcore.jsdelivr.net/gh/lizina66/api/img/202302020010820.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-06</div><div class="title">1.1_初识Java</div></div></a></div><div><a href="/2023/03/06/2-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="2.2_Java基础语法"><img class="cover" src="https://t.lizi.moe/fj" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-06</div><div class="title">2.2_Java基础语法</div></div></a></div><div><a href="/2023/03/07/1_%E5%88%9D%E8%AF%86JAVA/" title="1.2_初识JAVA"><img class="cover" src="https://gcore.jsdelivr.net/gh/lizina66/api/img/202302020010820.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-07</div><div class="title">1.2_初识JAVA</div></div></a></div><div><a href="/2023/03/07/2_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/" title="2.1_java基础知识点"><img class="cover" src="https://gcore.jsdelivr.net/gh/lizina66/api/img/202302020010820.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-07</div><div class="title">2.1_java基础知识点</div></div></a></div><div><a href="/2023/03/07/3_%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/" title="3_变量 常量 关键字"><img class="cover" src="https://gcore.jsdelivr.net/gh/lizina66/api/img/202302020010820.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-07</div><div class="title">3_变量 常量 关键字</div></div></a></div><div><a href="/2023/03/07/4_%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/" title="4_基本变量类型"><img class="cover" src="https://gcore.jsdelivr.net/gh/lizina66/api/img/202302020010820.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-07</div><div class="title">4_基本变量类型</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">复读机</div><div class="author-info__description">= 祝您早上、中午、晚上好！ =</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wood-sheep"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">祝你早上、中午、晚上好！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E9%A2%98%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">附加题：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81-amp-%E5%92%8C-amp-amp-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">1、&amp;和&amp;&amp;区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81jdk%E5%92%8Cjre%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">2、jdk和jre区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81switch%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">3、switch支持的数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="toc-number">1.4.</span> <span class="toc-text">4、JVM内存划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">5、值传递和引用传递的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">6、成员变量和局部变量的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.7.</span> <span class="toc-text">7、构造方法注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.8.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81-static%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F-%E6%96%B9%E6%B3%95%E5%92%8C%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.9.</span> <span class="toc-text">8、 static修饰变量 方法和代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number">1.10.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Object%E7%9A%84toString"><span class="toc-number">1.11.</span> <span class="toc-text">9、Object的toString()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81abstract%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.12.</span> <span class="toc-text">10、abstract抽象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E5%A4%9A%E6%80%81%EF%BC%9A"><span class="toc-number">1.13.</span> <span class="toc-text">11、多态：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.14.</span> <span class="toc-text">12、访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.15.</span> <span class="toc-text">13、内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%8110%E4%B8%AA%E5%BC%82%E5%B8%B8%E5%90%8D%E5%AD%97"><span class="toc-number">1.16.</span> <span class="toc-text">14、10个异常名字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81throws%E5%92%8Cthrow%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.17.</span> <span class="toc-text">15、throws和throw的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E5%85%B3%E9%94%AE%E5%AD%97-throws-throw-try-catch-finally%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89-%E5%9C%A8try%E5%9D%97%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%97"><span class="toc-number">1.18.</span> <span class="toc-text">JAVA语言如何进行异常处理,关键字:throws, throw,try, catch, finally分别代表什么意义?在try块中可以抛出异常吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81Error%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.19.</span> <span class="toc-text">16、Error和Exception的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E5%BC%82%E5%B8%B8%E5%88%86%E4%B8%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8%EF%BC%88%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8%EF%BC%89%EF%BC%9A"><span class="toc-number">1.20.</span> <span class="toc-text">17、异常分为运行时异常和检查异常（编译异常）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E8%B0%83%E7%94%A8%E8%80%85%E9%92%88%E5%AF%B9%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9C%892%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.21.</span> <span class="toc-text">18、调用者针对方法声明的异常有2种处理方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81%E5%8D%95%E4%BE%8B-%E6%87%92%E6%B1%89%E5%BC%8F%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">1.22.</span> <span class="toc-text">19、单例 懒汉式饿汉式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81Collection%E5%92%8CCollections%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.23.</span> <span class="toc-text">20、Collection和Collections的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.24.</span> <span class="toc-text">21、泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81ArrayList%E7%89%B9%E7%82%B9-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.25.</span> <span class="toc-text">22、ArrayList特点 扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81hashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.26.</span> <span class="toc-text">23、hashMap底层原理*********</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81hashcode%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">1.27.</span> <span class="toc-text">24、hashcode和equals的区别和联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="toc-number">1.28.</span> <span class="toc-text">25、ArrayList和LinkedList区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list%E5%92%8Cset%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.29.</span> <span class="toc-text">list和set的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Collections%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">Collections类常用方法总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Arrays%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">Arrays数组操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88%E7%B1%BB%E6%A1%86%E6%9E%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%8F%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">Java集合类框架的基本接口有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81ArrayList%E3%80%81hashmap%E3%80%81hashtable%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text">26、ArrayList、hashmap、hashtable扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81HashSet%E5%BA%95%E5%B1%82-%E7%85%A7%E7%9D%80HashMap%E5%BA%95%E5%B1%82%E5%9B%9E%E7%AD%94"><span class="toc-number">4.2.</span> <span class="toc-text">27、HashSet底层 照着HashMap底层回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">4.3.</span> <span class="toc-text">28、字符串常量池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81Integer%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B8%B8%E9%87%8F%E6%B1%A0-%E7%BC%93%E5%AD%98%E4%BA%86-128%E5%88%B0127%E4%B9%8B%E9%97%B4%E7%9A%84%E5%80%BC"><span class="toc-number">4.4.</span> <span class="toc-text">29、Integer有一个常量池 缓存了-128到127之间的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.5.</span> <span class="toc-text">30、枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F3%E7%A7%8D"><span class="toc-number">4.6.</span> <span class="toc-text">31、线程同步的方式3种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81sleep%E5%92%8Cwait%E5%8C%BA%E5%88%AB"><span class="toc-number">4.7.</span> <span class="toc-text">32、sleep和wait区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">4.8.</span> <span class="toc-text">33、面向对象的基本特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.9.</span> <span class="toc-text">34、深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E5%A6%82%E4%BD%95%E9%80%80%E5%87%BA%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.10.</span> <span class="toc-text">35、如何退出多重循环</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#char%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E8%B4%AE%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">5.</span> <span class="toc-text">char型变量中能不能存贮一个中文汉字?为什么?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E5%87%BA%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%EF%BC%8C%E5%8C%85%EF%BC%8C%E6%8E%A5%E5%8F%A3%EF%BC%8C%E8%AF%B7%E5%90%84%E4%B8%BE5%E4%B8%AA"><span class="toc-number">6.</span> <span class="toc-text">说出一些常用的类，包，接口，请各举5个</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0final-finally-finalize%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">描述final, finally, finalize的区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81java%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">1、java有哪些基本数据类型 什么是自动装箱？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%9C%A8%E4%B8%8D%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E5%8F%98%E9%87%8F%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%AE%A9int%E5%8F%98%E9%87%8Fa%E5%92%8Cint%E5%8F%98%E9%87%8Fb%E4%BA%92%E6%8D%A2"><span class="toc-number">9.</span> <span class="toc-text">2、算法实现之在不引入其他变量的情况下让int变量a和int变量b互换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E8%BE%93%E5%87%BA1-100%E4%B9%8B%E9%97%B4%E7%9A%84%E6%89%80%E6%9C%89%E7%9A%84%E7%B4%A0%E6%95%B0%EF%BC%8C%E6%89%80%E8%B0%93%E7%B4%A0%E6%95%B0%EF%BC%9A%E5%8F%AA%E8%83%BD%E8%A2%AB1%E5%92%8C%E6%9C%AC%E8%BA%AB%E6%95%B4%E9%99%A4%E7%9A%84%E7%A7%B0%E4%B8%BA%E7%B4%A0%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">3、编写一个方法输出1-100之间的所有的素数，所谓素数：只能被1和本身整除的称为素数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E6%9C%891%E3%80%812%E3%80%813%E3%80%814%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E8%83%BD%E7%BB%84%E6%88%90%E5%A4%9A%E5%B0%91%E4%B8%AA%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E4%B8%94%E6%97%A0%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E7%9A%84%E4%B8%89%E4%BD%8D%E6%95%B0%EF%BC%9F%E9%83%BD%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">4、有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">12.</span> <span class="toc-text">5、冒泡排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E4%B8%80%E7%90%83%E4%BB%8E100%E7%B1%B3%E9%AB%98%E5%BA%A6%E8%87%AA%E7%94%B1%E8%90%BD%E4%B8%8B%EF%BC%8C%E6%AF%8F%E6%AC%A1%E8%90%BD%E5%9C%B0%E5%90%8E%E5%8F%8D%E8%B7%B3%E5%9B%9E%E5%8E%9F%E9%AB%98%E5%BA%A6%E7%9A%84%E4%B8%80%E5%8D%8A%EF%BC%9B%E5%86%8D%E8%90%BD%E4%B8%8B%EF%BC%8C%E6%B1%82%E5%AE%83%E5%9C%A8-%E7%AC%AC10%E6%AC%A1%E8%90%BD%E5%9C%B0%E6%97%B6%EF%BC%8C%E5%85%B1%E7%BB%8F%E8%BF%87%E5%A4%9A%E5%B0%91%E7%B1%B3%EF%BC%9F%E7%AC%AC10%E6%AC%A1%E5%8F%8D%E5%BC%B9%E5%A4%9A%E9%AB%98%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">6、一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在 第10次落地时，共经过多少米？第10次反弹多高？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">7、静态变量和实例变量的区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81%E8%AF%B4%E8%AF%B4final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">8、说说final关键字的用法？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">16.</span> <span class="toc-text">9、选择排序算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E3%80%81-x3D-x3D-%E5%92%8Cequals%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">10、&#x3D;&#x3D; 和equals区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%AF%B7%E5%86%99%E5%87%BA%EF%BC%9A%E7%88%B6%E7%B1%BB%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E7%88%B6%E7%B1%BB%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E5%AD%90%E7%B1%BB%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%EF%BC%8C%E5%AD%90%E7%B1%BB%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%82%E8%BF%99%E5%85%AD%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">18.</span> <span class="toc-text">11、创建一个子类对象，请写出：父类静态代码块，父类构造方法，父类代码块，子类代码块，子类构造，子类静态代码块。这六个对象的执行顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">19.</span> <span class="toc-text">12、抽象类和接口的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13%E3%80%81int%E5%92%8CInteger%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">13、int和Integer有什么区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14%E3%80%81Hashtable%E5%92%8CHashMap%E5%8C%BA%E5%88%AB"><span class="toc-number">21.</span> <span class="toc-text">14、Hashtable和HashMap区别?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3%EF%BC%9F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">22.</span> <span class="toc-text">15、什么是类？什么是对象？什么是接口？接口和类的继承有什么本质区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16%E3%80%81String-s-x3D-new-String-%E2%80%9Cxyz%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">16、String s &#x3D; new String(“xyz”);创建了几个字符串对象？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17%E3%80%81Comparable%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">24.</span> <span class="toc-text">17、Comparable接口的用途</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E5%AD%98%E5%82%A8%E5%AD%A6%E7%94%9F%E5%AF%B9%E8%B1%A1-%E5%A6%82%E4%BD%95%E6%8E%92%E5%BA%8F"><span class="toc-number">24.1.</span> <span class="toc-text">ArrayList存储学生对象 如何排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#comparable%E5%92%8Ccomparator%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%94%A8%E9%80%94%EF%BC%9F%E5%88%97%E5%87%BA%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">comparable和comparator接口的用途？列出他们的区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18%E3%80%81Overload-%E5%92%8C-Override-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8COverload%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">18、Overload 和 Override 的区别，Overload方法是否可以改变返回值的类型？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="toc-number">27.</span> <span class="toc-text">19、二分查找法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20%E3%80%81String-StringBuffer-StringBuilder%E5%8C%BA%E5%88%AB"><span class="toc-number">28.</span> <span class="toc-text">20、String  StringBuffer StringBuilder区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">29.</span> <span class="toc-text">String常用方法：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21%E3%80%81%E7%BB%99%E5%AE%9A%E4%B8%A4%E4%B8%AA%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84a%E5%92%8Cb%EF%BC%8C%E8%A6%81%E6%B1%82%E9%99%A4%E5%8E%BBa%E4%B8%AD%E5%8C%85%E5%90%ABb%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E9%A1%B9%EF%BC%8C%E5%BE%97%E5%88%B0%E6%95%B0%E7%BB%84c%E3%80%82%E8%AF%B4%E6%98%8E%EF%BC%9Aa%E5%92%8Cb%E4%B8%AD%E9%83%BD%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E4%B8%BAnull%E7%9A%84%E5%85%83%E7%B4%A0%E3%80%82"><span class="toc-number">30.</span> <span class="toc-text">21、给定两个一维字符串数组a和b，要求除去a中包含b中元素的项，得到数组c。说明：a和b中都可能存在为null的元素。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22%E3%80%81%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2-%E9%80%9A%E8%BF%87%E9%80%92%E5%BD%92-%E8%BF%94%E5%9B%9E%E9%80%86%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">31.</span> <span class="toc-text">22、输入一个字符串  通过递归 返回逆序字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23%E3%80%81%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%AF%94%E5%A6%82-String-s-x3D-%E2%80%9Daabbbc%E2%80%9D-%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0"><span class="toc-number">32.</span> <span class="toc-text">23、输入一个字符串 比如 String s&#x3D;”aabbbc” 求字符串中每个字符的出现次数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24%E3%80%81%E9%80%92%E5%BD%92%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6-%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-number">33.</span> <span class="toc-text">24、递归查找指定目录所有文件  输出文件名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25%E3%80%81%E4%BD%BF%E7%94%A8%E5%AD%97%E8%8A%82%E6%B5%81%E5%B0%86c-x2F-1-txt-%E5%A4%8D%E5%88%B6%E5%88%B0d-x2F-2-txt"><span class="toc-number">34.</span> <span class="toc-text">25、使用字节流将c:&#x2F;1.txt 复制到d:&#x2F;2.txt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E6%9C%89%E5%93%AA%E4%BA%9B-%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E5%8A%A0%E9%80%9F%E6%96%B9%E5%BC%8F"><span class="toc-number">35.</span> <span class="toc-text">26、字节流有哪些? 缓冲流的加速方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E4%BD%A0%E6%8E%A8%E8%8D%90%E5%93%AA%E4%B8%80%E7%A7%8D"><span class="toc-number">36.</span> <span class="toc-text">27、多线程有几种实现方式?你推荐哪一种</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28%E3%80%81synchronized%E5%92%8CLock%E9%94%81%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">37.</span> <span class="toc-text">28、synchronized和Lock锁两者区别：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">38.</span> <span class="toc-text">产生多线程死锁的必要条件及解决方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%BA%8F%E5%88%97%E5%8C%96-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0java%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">39.</span> <span class="toc-text">29、什么是java序列化?如何实现java序列化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30%E3%80%81%E5%85%94%E5%AD%90%E9%80%92%E5%BD%92"><span class="toc-number">40.</span> <span class="toc-text">30、兔子递归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#31%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">41.</span> <span class="toc-text">31、插入排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32%E3%80%81java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">42.</span> <span class="toc-text">32、java中创建对象的方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33%E3%80%81%E5%88%9B%E5%BB%BAClass%E5%AF%B9%E8%B1%A1%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">43.</span> <span class="toc-text">33、创建Class对象的3种方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#34%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84HashMap"><span class="toc-number">44.</span> <span class="toc-text">34、如何实现线程安全的HashMap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">45.</span> <span class="toc-text">ConcurrentHashMap实现原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#35%E3%80%81oracle%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%88%86%E7%B1%BB-%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">46.</span> <span class="toc-text">35、oracle多表连接的分类  内连接和外连接的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36%E3%80%81oracle%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0-%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8D"><span class="toc-number">47.</span> <span class="toc-text">36、oracle中常用的函数  分别介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#37%E3%80%81%E8%A1%8C%E8%BD%AC%E5%88%97-%E5%88%97%E8%BD%AC%E8%A1%8C"><span class="toc-number">48.</span> <span class="toc-text">37、行转列  列转行</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#38%E3%80%81oracle%E5%92%8Cmysql%E5%88%86%E9%A1%B5"><span class="toc-number">49.</span> <span class="toc-text">38、oracle和mysql分页</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39%E3%80%81oracle%E5%92%8Cmysql%E5%8C%BA%E5%88%AB"><span class="toc-number">50.</span> <span class="toc-text">39、oracle和mysql区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E5%85%B7%E6%9C%89%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E6%A6%82%E5%BF%B5-%E5%B8%B8%E7%94%A8MyISAM%E4%B8%8EInnoDB%E5%8C%BA%E5%88%AB"><span class="toc-number">51.</span> <span class="toc-text">Mysql具有存储引擎的概念 常用MyISAM与InnoDB区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40%E3%80%81%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E5%BE%88%E6%85%A2-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-number">52.</span> <span class="toc-text">40、查询语句执行速度很慢 如何优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#41%E3%80%81-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">53.</span> <span class="toc-text">41、 数据库三大范式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#42%E3%80%81%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%92%8C%E4%BF%AE%E6%94%B9%E8%A1%A8"><span class="toc-number">54.</span> <span class="toc-text">42、创建表和修改表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#43%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%92%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">55.</span> <span class="toc-text">43、索引的作用？和它的优缺点是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#44%E3%80%81%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%AD%97%E6%AE%B5%E9%80%82%E5%90%88%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">56.</span> <span class="toc-text">44、什么样的字段适合建索引？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Oracle%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%B4%A2%E5%BC%95%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">57.</span> <span class="toc-text">Oracle中创建了索引，什么样的原因可能使索引不能正常使用？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45%E3%80%81%E5%86%99%E4%B8%80%E6%AE%B5jdbc%E4%BB%A3%E7%A0%81"><span class="toc-number">58.</span> <span class="toc-text">45、写一段jdbc代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#46%E3%80%81PreparedStatement%E5%92%8CStatement%E5%8C%BA%E5%88%AB"><span class="toc-number">59.</span> <span class="toc-text">46、PreparedStatement和Statement区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#47%E3%80%81tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">60.</span> <span class="toc-text">47、tomcat服务器文件夹下有哪些子文件夹，每个子文件夹的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#48%E3%80%81%E4%B8%80%E4%B8%AAweb%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">61.</span> <span class="toc-text">48、一个web项目的基本目录结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#49%E3%80%81request%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">62.</span> <span class="toc-text">49、request对象的常用方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#50%E3%80%81jsp9%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%88-%E5%B8%B8%E9%97%AE%EF%BC%89%EF%BC%9A"><span class="toc-number">63.</span> <span class="toc-text">50、jsp9大内置对象（********常问）：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#51%E3%80%81jsp%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">64.</span> <span class="toc-text">51、jsp执行过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#52%E3%80%81get%E5%92%8Cpost%E5%8C%BA%E5%88%AB"><span class="toc-number">65.</span> <span class="toc-text">52、get和post区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#53%E3%80%81%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E5%8C%BA%E5%88%AB"><span class="toc-number">66.</span> <span class="toc-text">53、转发和重定向区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#54%E3%80%81%E5%BD%93%E6%88%91%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E5%90%8E-%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">67.</span> <span class="toc-text">54、当我在地址栏输入URL回车后 发生了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-HTTP-%E5%8D%8F%E8%AE%AE-UDP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">67.0.1.</span> <span class="toc-text">TCP  HTTP 协议  UDP 协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#55%E3%80%81request-getAttribute-%E5%92%8C-request-getParameter-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="toc-number">68.</span> <span class="toc-text">55、request.getAttribute() 和 request.getParameter() 有何区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#56%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFcookie-cookie%E7%9A%84%E4%BD%9C%E7%94%A8-%EF%BC%88%E4%B8%80%E8%88%AC%E4%B8%8D%E9%97%AE%EF%BC%89"><span class="toc-number">69.</span> <span class="toc-text">56、什么是cookie  cookie的作用 （一般不问）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#57%E3%80%81-session%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">70.</span> <span class="toc-text">57、 session的原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#58%E3%80%81session%E5%92%8Ccookie%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">71.</span> <span class="toc-text">58、session和cookie的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#59%E3%80%81servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-load-on-startup%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">72.</span> <span class="toc-text">59、servlet生命周期 load-on-startup的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#60%E3%80%81cookie%E5%AE%8C%E6%88%905%E5%88%86%E9%92%9F%E5%85%8D%E7%99%BB%E5%BD%95-%E5%8F%AA%E9%9C%80%E8%A6%81%E6%9C%88%E8%80%83%E4%B9%8B%E5%89%8D%E8%83%8C-%EF%BC%88%E4%B8%80%E8%88%AC%E4%B8%8D%E9%97%AE%EF%BC%89"><span class="toc-number">73.</span> <span class="toc-text">60、cookie完成5分钟免登录(只需要月考之前背)（一般不问）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#61%E3%80%81jsp%E9%A1%B5%E9%9D%A2%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">74.</span> <span class="toc-text">61、jsp页面传递数据的方式?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#62%E3%80%81jsp-%E5%9B%9B%E5%A4%A7%E5%9F%9F%E5%92%8C%E6%AF%8F%E4%B8%AA%E5%9F%9F%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">75.</span> <span class="toc-text">62、jsp 四大域和每个域数据的使用范围</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#63%E3%80%81tomcat%E5%AE%B9%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAservlet%E7%B1%BB%E5%AE%9E%E4%BE%8B%EF%BC%9F%E7%94%A8%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F-%E4%B8%80%E8%88%AC%E4%B8%8D%E9%97%AE"><span class="toc-number">76.</span> <span class="toc-text">63、tomcat容器是如何创建servlet类实例？用到了什么原理？(一般不问)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#64%E3%80%81JDBC%E4%B8%AD%E7%9A%84CLOB%E5%92%8CBLOB%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%80%E8%88%AC%E4%B8%8D%E9%97%AE"><span class="toc-number">77.</span> <span class="toc-text">64、JDBC中的CLOB和BLOB数据类型是什么 (一般不问)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#65%E3%80%81jsp%E9%9D%99%E6%80%81%E5%8C%85%E5%90%AB%E5%92%8C%E5%8A%A8%E6%80%81%E5%8C%85%E5%90%AB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">78.</span> <span class="toc-text">65、jsp静态包含和动态包含的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#66%E3%80%81jsp-9%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">79.</span> <span class="toc-text">66、jsp 9大内置对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#67%E3%80%81%EF%BC%88%E4%B8%80%E8%88%AC%E4%B8%8D%E9%97%AE%EF%BC%89%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%E5%AE%83%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">80.</span> <span class="toc-text">67、（一般不问）连接池是什么？ 它的好处是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#68%E3%80%81%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">81.</span> <span class="toc-text">68、装饰者模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">82.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#69%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFmvc%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%AF%8F%E4%B8%AA%E9%83%A8%E5%88%86%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF"><span class="toc-number">83.</span> <span class="toc-text">69、什么是mvc设计模式  每个部分使用的技术</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#70%E3%80%81%E4%BA%8B%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88-jdbc%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="toc-number">84.</span> <span class="toc-text">70、事务是什么? jdbc控制事务的模板?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#71%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8-Filter-%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%88%E4%B8%80%E8%88%AC%E4%B8%8D%E9%97%AE%EF%BC%89"><span class="toc-number">85.</span> <span class="toc-text">71、过滤器(Filter)怎么执行的（一般不问）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#72%E3%80%81%E6%95%8F%E6%84%9F%E5%AD%97%E7%AC%A6%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">86.</span> <span class="toc-text">72、敏感字符过滤器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#73%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%8F%E8%AF%BB-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-%E5%B9%BB%E8%AF%BB-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">87.</span> <span class="toc-text">73、什么是脏读  不可重复读  幻读 解决方法？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#74%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E6%98%AF%EF%BC%9A-%E6%A6%82%E5%BF%B5%E6%80%A7%E9%97%AE%E9%A2%98%E2%80%93%E9%9D%A2%E8%AF%95"><span class="toc-number">88.</span> <span class="toc-text">74、事务的四大特性是：(概念性问题–面试)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#75%E3%80%81%E7%BC%96%E7%A0%81%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88%E9%9C%80%E8%A6%81%E7%94%A8%E8%AF%AD%E8%A8%80%E8%AF%B4%E5%87%BA%E6%9D%A5%EF%BC%89"><span class="toc-number">89.</span> <span class="toc-text">75、编码过滤器（需要用语言说出来）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%8F%E6%84%9F%E5%AD%97%E7%AC%A6%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88%E9%9C%80%E8%A6%81%E7%94%A8%E8%AF%AD%E8%A8%80%E8%AF%B4%E5%87%BA%E6%9D%A5%EF%BC%89"><span class="toc-number">90.</span> <span class="toc-text">敏感字符过滤器（需要用语言说出来）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#76%E3%80%81%E5%B7%B2%E7%9F%A5%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88%EF%BC%8C%E8%A6%81%E6%B1%82%E5%9C%A8jsp%E4%B8%AD%E9%80%9A%E8%BF%87jstl%E9%81%8D%E5%8E%86%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E5%92%8C%E7%94%A8%E6%88%B7%E5%AF%B9%E5%BA%94%E9%83%A8%E9%97%A8%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">91.</span> <span class="toc-text">76、已知有两个集合，要求在jsp中通过jstl遍历用户数据和用户对应部门的数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#77%E3%80%81%E8%B7%A8%E5%9F%9F"><span class="toc-number">92.</span> <span class="toc-text">77、跨域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#78%E3%80%81cookies%E3%80%81sessionStorage%E5%92%8ClocalStorage%E8%A7%A3%E9%87%8A%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-number">93.</span> <span class="toc-text">78、cookies、sessionStorage和localStorage解释及区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sessionStorage%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">93.1.</span> <span class="toc-text">sessionStorage的使用：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#79%E3%80%81maven%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">94.</span> <span class="toc-text">79、maven的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAmaven%E7%9A%84web%E9%A1%B9%E7%9B%AE"><span class="toc-number">94.0.1.</span> <span class="toc-text">创建maven的web项目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#80%E3%80%81hibernate%E7%9A%84%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4"><span class="toc-number">95.</span> <span class="toc-text">80、hibernate的开发步骤</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#81%E3%80%81hibernate%E4%B8%ADget%E5%92%8Cload%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">96.</span> <span class="toc-text">81、hibernate中get和load的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#82%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFHibernate%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E3%80%82"><span class="toc-number">97.</span> <span class="toc-text">82、什么是Hibernate延迟加载。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#83%E3%80%81hibernate%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">98.</span> <span class="toc-text">83、hibernate一级缓存和二级缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">99.</span> <span class="toc-text">mybatis一级缓存和二级缓存的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#84%E3%80%81hibernate%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">100.</span> <span class="toc-text">84、hibernate查询方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#85%E3%80%81hibernate%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">101.</span> <span class="toc-text">85、hibernate对象的三种状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#86%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">102.</span> <span class="toc-text">86、什么是悲观锁和乐观锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFhibernate%E5%92%8Cmybatis%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">103.</span> <span class="toc-text">什么是hibernate和mybatis悲观锁和乐观锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#87%E3%80%81-mybatis-%E5%8C%BA%E5%88%AB"><span class="toc-number">104.</span> <span class="toc-text">87、 mybatis  #{}   ${}区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%B5%81%E7%A8%8B"><span class="toc-number">105.</span> <span class="toc-text">分页流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#88%E3%80%81mybatis%E5%8A%A8%E6%80%81mapper%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-mapper%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%83%BD%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD"><span class="toc-number">106.</span> <span class="toc-text">88、mybatis动态mapper的实现原理?mapper接口中的方法能不能重载?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mybatis%E4%B8%AD%E9%80%9A%E5%B8%B8%E4%B8%80%E4%B8%AAXml%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%EF%BC%8C%E9%83%BD%E4%BC%9A%E5%86%99%E4%B8%80%E4%B8%AADao%E6%8E%A5%E5%8F%A3%E4%B8%8E%E4%B9%8B%E5%AF%B9%E5%BA%94%EF%BC%8C%E8%AF%B7%E9%97%AE%EF%BC%8C%E8%BF%99%E4%B8%AADao%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%9FDao%E6%8E%A5%E5%8F%A3%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%8F%82%E6%95%B0%E4%B8%8D%E5%90%8C%E6%97%B6%EF%BC%8C%E6%96%B9%E6%B3%95%E8%83%BD%E9%87%8D%E8%BD%BD%E5%90%97%EF%BC%9F"><span class="toc-number">107.</span> <span class="toc-text">Mybatis中通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？？Dao接口里的方法，参数不同时，方法能重载吗？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#89%E3%80%81-mybatis%E7%9A%84%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%92%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">108.</span> <span class="toc-text">89、  mybatis的多对一和一对多如何实现？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#90%E3%80%81Hibernate%E5%92%8CMybatis%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">109.</span> <span class="toc-text">90、Hibernate和Mybatis的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB"><span class="toc-number">109.1.</span> <span class="toc-text">91、动态代理区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#92%E3%80%81spring%E8%83%BD%E5%B8%AE%E6%88%91%E4%BB%AC%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85-%E4%BB%80%E4%B9%88%E6%98%AFspring"><span class="toc-number">110.</span> <span class="toc-text">92、spring能帮我们做什么事情 (什么是spring)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#93%E3%80%81%E8%AF%B7%E5%86%99%E5%87%BA%E5%9C%A8applicationContext-xml%E4%B8%AD%E5%88%9B%E5%BB%BApackage1-DestBean%E5%AF%B9%E8%B1%A1%E6%94%BE%E5%85%A5IOC%E5%AE%B9%E5%99%A8%E5%B9%B6%E4%B8%94%E6%B3%A8%E5%85%A5sourceBean%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BB%A3%E7%A0%81-%E6%89%8B%E5%86%99%E7%BA%B8%E4%B8%8A"><span class="toc-number">111.</span> <span class="toc-text">93、请写出在applicationContext.xml中创建package1.DestBean对象放入IOC容器并且注入sourceBean对象的代码.(手写纸上)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#94%E3%80%81Spring%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86JDK%E5%92%8CCGLIB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">112.</span> <span class="toc-text">94、Spring的两种代理JDK和CGLIB的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#95%E3%80%81Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">113.</span> <span class="toc-text">95、Spring中的设计模式有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#96%E3%80%81Resource%E5%92%8CAutowired%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">114.</span> <span class="toc-text">96、Resource和Autowired注解的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#98%E3%80%81IOC%E6%98%AF%E4%BB%80%E4%B9%88-DI%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">115.</span> <span class="toc-text">98、IOC是什么,DI是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#99%E3%80%81-%E4%BB%80%E4%B9%88%E6%98%AFaop-%E6%9C%89%E5%87%A0%E7%A7%8D%E9%80%9A%E7%9F%A5"><span class="toc-number">116.</span> <span class="toc-text">99、 什么是aop?有几种通知?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#100%E3%80%81%E5%88%9B%E5%BB%BAjdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">117.</span> <span class="toc-text">100、创建jdk动态代理对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#101%E3%80%81-spring-mvc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E5%8F%82%E8%80%83%E8%AF%BE%E4%BB%B6"><span class="toc-number">118.</span> <span class="toc-text">101、 spring mvc工作流程 参考课件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#102%E3%80%81Mybatis-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-sql-%E6%B3%A8%E5%85%A5%EF%BC%9Fmybatis-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">119.</span> <span class="toc-text">102、Mybatis 如何防止 sql 注入？mybatis 拦截器了解过吗，应用场景是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#103%E3%80%81fastdfs"><span class="toc-number">120.</span> <span class="toc-text">103、fastdfs</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#104%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFAjax%E5%92%8CJSON%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">121.</span> <span class="toc-text">104、什么是Ajax和JSON，它们的优缺点？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#105%E3%80%81%E7%AE%80%E8%BF%B0ajax%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">122.</span> <span class="toc-text">105、简述ajax的执行过程？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#106%E3%80%81ajax%E8%AF%B7%E6%B1%82%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E9%87%8Ajson%E6%95%B0%E6%8D%AE"><span class="toc-number">123.</span> <span class="toc-text">106、ajax请求时，如何解释json数据?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#107%E3%80%81ajax%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">124.</span> <span class="toc-text">107、ajax的最大的特点是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#108%E3%80%81Spring%E6%94%AF%E6%8C%81%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%9F"><span class="toc-number">125.</span> <span class="toc-text">108、Spring支持几种类型的事务管理？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#109%E3%80%81spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">126.</span> <span class="toc-text">109、spring事务传播特性有哪些？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#110%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJSONP%E5%92%8CCORS-%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">127.</span> <span class="toc-text">110、什么是JSONP和CORS,它们的区别是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#111%E3%80%81%E8%A7%92%E8%89%B2%E7%B1%BBRole%E6%9C%89%E5%B1%9E%E6%80%A7-roleId-roleName-%E7%94%A8%E6%88%B7%E7%B1%BBUser%E6%9C%89%E5%B1%9E%E6%80%A7-name-age-role-%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AAList%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84json%E5%AD%97%E7%AC%A6%E4%B8%B2-%E9%9B%86%E5%90%88%E4%B8%AD%E8%87%B3%E5%B0%91%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E5%92%8C%E4%B8%80%E4%B8%AA%E8%A7%92%E8%89%B2"><span class="toc-number">128.</span> <span class="toc-text">111、角色类Role有属性(roleId, roleName) , 用户类User有属性(name,age,role) 写出一个List对象转换后的json字符串. 集合中至少包含一个用户和一个角色.</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#112%E3%80%81springmvc%E6%B3%A8%E8%A7%A3"><span class="toc-number">129.</span> <span class="toc-text">112、springmvc注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#controller%E5%92%8CRestController%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">129.1.</span> <span class="toc-text">controller和RestController的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#113%E3%80%81springmvc%E6%80%8E%E4%B9%88%E5%81%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-number">130.</span> <span class="toc-text">113、springmvc怎么做文件上传</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#oss%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">131.</span> <span class="toc-text">oss实现文件上传流程介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#114%E3%80%81%E4%BD%A0%E5%AF%B9springboot%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">132.</span> <span class="toc-text">114、你对springboot的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#115%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFrestful"><span class="toc-number">133.</span> <span class="toc-text">115、什么是restful</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#116%E3%80%81redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">134.</span> <span class="toc-text">116、redis的数据类型有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#117%E3%80%81redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">135.</span> <span class="toc-text">117、redis的持久化机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">136.</span> <span class="toc-text">redis的应用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#118%E3%80%81-NOSQL%E5%92%8C%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%94%E8%BE%83"><span class="toc-number">137.</span> <span class="toc-text">118、 NOSQL和关系型数据库比较</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#119%E3%80%81ajax%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">138.</span> <span class="toc-text">119、ajax技术体系的组成部分有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#120%E3%80%81%E9%A1%B9%E7%9B%AE%E8%A1%8D%E8%BF%9B%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">139.</span> <span class="toc-text">120、项目衍进流程：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3"><span class="toc-number">140.</span> <span class="toc-text">自动生成接口文档</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">141.</span> <span class="toc-text">正向代理与反向代理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">142.</span> <span class="toc-text">gc垃圾回收</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">143.</span> <span class="toc-text">事务处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Springmvc%E5%92%8Cspring%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">144.</span> <span class="toc-text">Springmvc和spring的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">145.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">146.</span> <span class="toc-text">IO流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">147.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#git"><span class="toc-number">148.</span> <span class="toc-text">git</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#shiro"><span class="toc-number">149.</span> <span class="toc-text">shiro</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shiro-jwt-redis-%E6%97%A0%E7%8A%B6%E6%80%81token%E7%99%BB%E5%BD%95"><span class="toc-number">149.0.1.</span> <span class="toc-text">shiro+jwt+redis - 无状态token登录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rabbitMQ%EF%BC%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-kafka%EF%BC%89"><span class="toc-number">150.</span> <span class="toc-text">rabbitMQ（消息队列 kafka）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">150.0.1.</span> <span class="toc-text">工作模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">151.</span> <span class="toc-text">前后端分离项目中的日期格式化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#netflix-%E7%BD%91%E9%A3%9E"><span class="toc-number">152.</span> <span class="toc-text">netflix(网飞)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#eureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0"><span class="toc-number">153.</span> <span class="toc-text">eureka服务注册与发现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%8D%E5%8A%A1"><span class="toc-number">154.</span> <span class="toc-text">ribbon负载均衡服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenFeign%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8"><span class="toc-number">155.</span> <span class="toc-text">OpenFeign服务接口调用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hystrix%E6%96%AD%E8%B7%AF%E5%99%A8"><span class="toc-number">156.</span> <span class="toc-text">Hystrix断路器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Geteway%E7%BD%91%E5%85%B3"><span class="toc-number">157.</span> <span class="toc-text">Geteway网关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">158.</span> <span class="toc-text">代码生成器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mybatis-plus"><span class="toc-number">159.</span> <span class="toc-text">mybatis-plus</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nacos%EF%BC%88%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%EF%BC%89"><span class="toc-number">160.</span> <span class="toc-text">nacos（服务注册与发现 配置中心）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dubbo"><span class="toc-number">161.</span> <span class="toc-text">dubbo</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssm"><span class="toc-number">162.</span> <span class="toc-text">ssm</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">163.</span> <span class="toc-text">Linux常用命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E4%B8%ADVi%E5%92%8CVim%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">164.</span> <span class="toc-text">Linux中Vi和Vim区别是什么?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springcloud"><span class="toc-number">165.</span> <span class="toc-text">springcloud</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">166.</span> <span class="toc-text">问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AE%E7%82%B9-%E5%B1%95%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%AE%E7%82%B9"><span class="toc-number">166.1.</span> <span class="toc-text">亮点  展现自己的亮点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">166.2.</span> <span class="toc-text">数据库设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%92%8C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%85%B3%E7%B3%BB-%E4%BA%86%E8%A7%A3%E5%BA%95%E5%B1%82%E5%AF%B9%E5%BC%80%E5%8F%91%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="toc-number">166.3.</span> <span class="toc-text">底层和应用开发关系  了解底层对开发什么好处</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="toc-number">167.</span> <span class="toc-text">前后端分离的项目，如何解决跨域问题的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9C%8B%E4%BD%A0%E9%A1%B9%E7%9B%AE%E8%B4%9F%E8%B4%A3%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8D%E5%A4%9A%EF%BC%8C%E6%80%8E%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%99%E4%B9%88%E9%95%BF%E6%97%B6%E9%97%B4"><span class="toc-number">168.</span> <span class="toc-text">看你项目负责的功能不多，怎么需要这么长时间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%BB%E8%81%8C"><span class="toc-number">169.</span> <span class="toc-text">为什么离职</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8B%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE"><span class="toc-number">170.</span> <span class="toc-text">介绍下你的项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E5%88%B03%E5%B9%B4%E7%9A%84%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92-%E5%BF%85%E9%97%AE"><span class="toc-number">170.1.</span> <span class="toc-text">2到3年的职业规划  必问********</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%85%AC%E5%8F%B8%E6%83%B3%E4%BA%86%E8%A7%A3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">170.2.</span> <span class="toc-text">对公司想了解的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%87%A0%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E7%9A%84%EF%BC%8C%E5%BC%80%E5%8F%91%E4%BA%86%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4"><span class="toc-number">171.</span> <span class="toc-text">你的项目几个人开发的，开发了多长时间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%A0%E4%BB%A5%E5%89%8D%E5%B7%A5%E8%B5%84%E5%A4%9A%E5%B0%91%EF%BC%9F%E6%9C%89%E4%BA%A4%E4%BA%94%E9%99%A9%E4%B8%80%E9%87%91%E5%90%97"><span class="toc-number">172.</span> <span class="toc-text">你以前工资多少？有交五险一金吗</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%A0%E6%9C%80%E5%BF%AB%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%83%BD%E5%A4%9F%E5%85%A5%E8%81%8C%EF%BC%9F"><span class="toc-number">173.</span> <span class="toc-text">你最快什么时候能够入职？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-2"><span class="toc-number">174.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue"><span class="toc-number">175.</span> <span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-number">175.0.1.</span> <span class="toc-text">vue组件的属性名介绍：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">175.0.2.</span> <span class="toc-text">使用箭头函数和普通函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6"><span class="toc-number">175.0.3.</span> <span class="toc-text">父组件调用子组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9B%B8%E4%BA%92%E8%B0%83%E5%8A%A8"><span class="toc-number">175.0.4.</span> <span class="toc-text">父子组件相互调动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E7%88%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">175.0.5.</span> <span class="toc-text">子组件调用父组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8D%E6%98%AF%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB%E7%9A%84%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8"><span class="toc-number">175.0.6.</span> <span class="toc-text">如何实现不是父子关系的组件之间的相互调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E9%A1%B9%E7%9B%AE%E7%9A%84ajax%E5%BA%93-axios"><span class="toc-number">175.0.7.</span> <span class="toc-text">vue项目的ajax库:axios</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#router"><span class="toc-number">175.0.8.</span> <span class="toc-text">router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-Vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">175.0.9.</span> <span class="toc-text">谈谈你对 Vue 生命周期的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%BB%99%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E9%A1%B9%E8%B5%8B%E5%80%BC%EF%BC%8CVue-%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E5%8F%98%E5%8C%96%E5%90%97%EF%BC%9F"><span class="toc-number">175.0.10.</span> <span class="toc-text">直接给一个数组项赋值，Vue 能检测到变化吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%BF%90%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">175.0.11.</span> <span class="toc-text">computed 和 watch 的区别和运用的场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-show-%E4%B8%8E-v-if-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">175.0.12.</span> <span class="toc-text">v-show 与 v-if 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-SPA-%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">175.0.13.</span> <span class="toc-text">说说你对 SPA 单页面的理解，它的优缺点分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MVVM%EF%BC%9F"><span class="toc-number">175.0.14.</span> <span class="toc-text">什么是 MVVM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E7%9A%84%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">175.0.15.</span> <span class="toc-text">Vue 的父组件和子组件生命周期钩子函数执行顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-keep-alive-%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">175.0.16.</span> <span class="toc-text">谈谈你对 keep-alive 的了解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%AD-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">175.0.17.</span> <span class="toc-text">组件中 data 为什么是一个函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-model-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">175.0.18.</span> <span class="toc-text">v-model 的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-router%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">175.0.19.</span> <span class="toc-text">vue-router路由模式有几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E6%A1%86%E6%9E%B6%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%91%E5%90%AC%EF%BC%9F"><span class="toc-number">175.0.20.</span> <span class="toc-text">Vue 框架怎么实现对象和数组的监听？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E3%80%81vue%E4%B8%AD%E7%9A%84key%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%EF%BC%88key%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%EF%BC%89"><span class="toc-number">175.0.21.</span> <span class="toc-text">react、vue中的key有什么作用？（key的内部原理）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E5%A6%82%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">175.0.22.</span> <span class="toc-text">Vue修改数组中的某个元素一定要用如下方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">175.0.23.</span> <span class="toc-text">虚拟 DOM 的优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F-DOM-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">175.0.24.</span> <span class="toc-text">虚拟 DOM 实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E6%9C%89%E5%AF%B9-Vue-%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">175.0.25.</span> <span class="toc-text">你有对 Vue 项目进行哪些优化？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">176.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ascii%E7%A0%81"><span class="toc-number">176.0.1.</span> <span class="toc-text">Ascii码</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/25/%E9%AA%8C%E8%AF%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E6%B3%A8%E8%A7%A3/" title="验证身份证号注解"><img src="https://t.lizi.moe/fj" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="验证身份证号注解"/></a><div class="content"><a class="title" href="/2023/09/25/%E9%AA%8C%E8%AF%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E6%B3%A8%E8%A7%A3/" title="验证身份证号注解">验证身份证号注解</a><time datetime="2023-09-25T03:06:31.000Z" title="发表于 2023-09-25 11:06:31">2023-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/24/java%E5%AE%8C%E6%95%B4%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/" title="java面试宝典"><img src="https://t.lizi.moe/fj" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java面试宝典"/></a><div class="content"><a class="title" href="/2023/03/24/java%E5%AE%8C%E6%95%B4%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/" title="java面试宝典">java面试宝典</a><time datetime="2023-03-24T01:12:44.000Z" title="发表于 2023-03-24 09:12:44">2023-03-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/23/%E7%AC%94%E8%AE%B0/" title="无题"><img src="https://t.lizi.moe/fj" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/03/23/%E7%AC%94%E8%AE%B0/" title="无题">无题</a><time datetime="2023-03-23T03:31:41.000Z" title="发表于 2023-03-23 11:31:41">2023-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/13/Math.random()%E5%B7%A7%E7%94%A8/" title="Math.random()技巧"><img src="https://t.lizi.moe/fj" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Math.random()技巧"/></a><div class="content"><a class="title" href="/2023/03/13/Math.random()%E5%B7%A7%E7%94%A8/" title="Math.random()技巧">Math.random()技巧</a><time datetime="2023-03-13T02:36:57.000Z" title="发表于 2023-03-13 10:36:57">2023-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/09/%E5%8A%9B%E6%89%A3%E7%AC%AC%E4%B8%80%E9%A2%98%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%92%8C/" title="力扣第一题两数相加"><img src="https://docimg3.docs.qq.com/image/AgAAC6u-TVOEorWJkK1EWL5jpWvfmIyG.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="力扣第一题两数相加"/></a><div class="content"><a class="title" href="/2023/03/09/%E5%8A%9B%E6%89%A3%E7%AC%AC%E4%B8%80%E9%A2%98%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%92%8C/" title="力扣第一题两数相加">力扣第一题两数相加</a><time datetime="2023-03-09T02:08:56.761Z" title="发表于 2023-03-09 10:08:56">2023-03-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 复读机</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">2023年3月4号诞生</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '823e9968cd7a47651ec8',
      clientSecret: '5660ff0dc0ab1fcc9816d728a4a00f36b23e8570',
      repo: 'wood-sheep.github.io',
      owner: 'wood-sheep',
      admin: ['wood-sheep'],
      id: '4f3296c1d1d6c9715ddcee6cbb2701f1',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>